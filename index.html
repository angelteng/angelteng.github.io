<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Code war of Angel">
<meta property="og:url" content="https://angelteng.github.io/blog/index.html">
<meta property="og:site_name" content="Code war of Angel">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code war of Angel">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://angelteng.github.io/blog/">





  <title>Code war of Angel</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code war of Angel</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/09/24/Redis笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/09/24/Redis笔记/" itemprop="url">Redis笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-24T09:59:52+08:00">
                2020-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="Redis模块组成"><a href="#Redis模块组成" class="headerlink" title="Redis模块组成"></a>Redis模块组成</h2><img src="/blog/2020/09/24/Redis笔记/1600873329328.png">
<h2 id="Redis数据结构（String，List-Hash-Set-SortSet-BitMap-HyperLogLog-GEO"><a href="#Redis数据结构（String，List-Hash-Set-SortSet-BitMap-HyperLogLog-GEO" class="headerlink" title="Redis数据结构（String，List,Hash,Set,SortSet,BitMap,HyperLogLog,GEO)"></a>Redis数据结构（String，List,Hash,Set,SortSet,BitMap,HyperLogLog,GEO)</h2><img src="/blog/2020/09/24/Redis笔记/1600873417868.png">
<ol>
<li>Redis 使用了一个哈希表来保存所有键值对。哈希表的每一项是一个 dictEntry 的结构体。dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节。key、value都是用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据指针。<img src="/blog/2020/09/24/Redis笔记/1.png"></li>
<li>Redis 解决哈希冲突的方式，就是链式哈希。</li>
<li>渐进式 rehash：<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间</li>
</ol>
</li>
<li>压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)</li>
<li>String类型以SDS结构体存储，包括三部分：buf–字节数组，保存实际数据。len：占 4 个字节，表示 buf 的已用长度。alloc：也占个 4 字节，表示 buf 的实际分配长度。</li>
<li>内存分配上：jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</li>
<li>hash类型使用压缩列表还是哈希表作为低层数据结构，主要取决与：<ol>
<li>hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。</li>
<li>hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。</li>
</ol>
</li>
<li>集合计算<img src="/blog/2020/09/24/Redis笔记/2.png"></li>
<li>时序序列：hash、sortset、 RedisTimeSeries</li>
<li>事务：使用MULTI和EXEC命令时，建议客户端使用pipeline，当使用pipeline时，客户端会把命令一次性批量发送给服务端。</li>
</ol>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ol>
<li>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果</li>
<li>select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。</li>
<li>性能瓶颈主要包括2个方面：<ol>
<li>任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：<ul>
<li>操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey、过期释放内存同样会产生耗时；</li>
<li>使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；</li>
<li>大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；</li>
<li>淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；</li>
<li>AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；</li>
<li>主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</li>
</ul>
</li>
<li>并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</li>
</ol>
</li>
</ol>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ol>
<li>Redis 是先执行命令，把数据写入内存，然后才记录日志。</li>
<li>AOF 日志也是在主线程中执行的。策略<pre><code>1. Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘，主线程调用fsync操作完成。
2. Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；使用后台的子线程异步完成 fsync 的操作。
3. No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。
</code></pre></li>
<li>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件。重写过程是由子进程 bgrewriteaof 来完成的。</li>
<li>重写的过程总结为“一个拷贝，两处日志”：主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</li>
<li>AOF重写子进程写入量大-&gt;fsync线程阻塞-&gt;主线程阻塞</li>
</ol>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ol>
<li>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照。策略：<ol>
<li>save：在主线程中执行，会导致阻塞；</li>
<li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li>
</ol>
</li>
<li>Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</li>
</ol>
<p>##主从模式</p>
<ol>
<li>步骤：<ol>
<li>从库给主库发送 psync 命令，表示要进行数据同步。psync 命令包含了主库的 runID 和复制进度 offset。</li>
<li>主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset。</li>
<li>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。</li>
<li>只要有从库存在，主库会记录 RDB 文件生成后收到的所有写操作到环形缓存区repl_backlog_buffer, 如果主库与从库建立了连接，写入client buffer：replication buffer中。当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库。</li>
</ol>
</li>
<li>通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</li>
<li>长连接复制是主从库正常运行后的常规同步阶段。在这个阶段中，主从库之间通过命令传播实现同步。</li>
<li>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前对于环形缓存区real_backlog_buffer的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。<ol>
<li>如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</li>
<li>可以调整repl_backlog_size 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 <em> 操作大小 - 主从库间网络传输命令速度 </em> 操作大小。</li>
</ol>
</li>
</ol>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><ol>
<li>流程<ol>
<li>监控：监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。</li>
<li>选主：主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。哨兵集群在判断了主库“客观下线”后，经过投票仲裁，选举一个 Leader 出来，由它负责实际的主从切换。</li>
<li>通知：在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。</li>
</ol>
</li>
<li>主观下线：哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。</li>
<li>客观下线：当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。</li>
<li>选主方法：<ol>
<li>筛选：1. 检查从库的当前在线状态；2. 在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好。</li>
<li>打分：进行三轮打分，这三个规则分别是从库优先级（slave-priority）、从库复制进度（slave_repl_offset）以及从库 ID 号（ID 号小的从库得分高）。只要在某一轮中，有从库得分最高，那么它就是主库了。</li>
</ol>
</li>
<li>哨兵集群发现：哨兵和主库建立起了连接，就可以在主库上PUB/SUB，当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</li>
<li>哨兵与从库建立连接：哨兵向主库发送 INFO 命令，主库把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接。</li>
<li>哨兵与客户端通讯：<img src="/blog/2020/09/24/Redis笔记/1600876246493.png"></li>
<li>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds</li>
</ol>
<h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><ol>
<li>部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。</li>
<li>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</li>
<li>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。</li>
<li>重定向<ol>
<li>原因：实例数量变动；负载均衡</li>
<li>步骤：当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。客户端更新缓存。</li>
<li>迁移部分完成：客户端就会收到一条 ASK 报错信息，返回最新实例地址，客户端需要给新实例发送 ASKING 命令，然后再发送操作命令。ASK 命令并不会更新客户端缓存的哈希槽分配信息。</li>
</ol>
</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><img src="/blog/2020/09/24/Redis笔记/3.jpg">
<ol>
<li>List用作队列时，为了保证消息可靠性，使用BRPOPLPUSH命令把消息取出的同时，还把消息插入到备份队列中，从而防止消费者故障导致消息丢失。每次执行BRPOPLPUSH命令后，当消费者成功消费取出的消息后，最好把备份队列中的消息删除，防止备份队列存储过多无用的数据。</li>
<li>丢消息情况及处理：<ol>
<li>生产者在发布消息时异常：<br> a) 网络故障或其他问题导致发布失败（直接返回错误，消息根本没发出去）<br> b) 网络抖动导致发布超时（可能发送数据包成功，但读取响应结果超时了，不知道结果如何）<br>消费者需要保证在收到重复消息时，依旧能保证业务的正确性（设计幂等逻辑）。</li>
<li>消费者在处理消息时异常：Streams则是采用ack的方式，消费成功后告知中间件。</li>
<li>消息队列中间件丢失消息: 在用Redis当作队列或存储数据时，是有可能丢失数据的：一个场景是，如果打开AOF并且是每秒写盘，因为这个写盘过程是异步的，Redis宕机时会丢失1秒的数据。而如果AOF改为同步写盘，那么写入性能会下降。另一个场景是，如果采用主从集群，如果写入量比较大，从库同步存在延迟，此时进行主从切换，也存在丢失数据的可能。总的来说，Redis不保证严格的数据完整性和主从切换时的一致性。我们在使用Redis时需要注意。</li>
</ol>
</li>
</ol>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ol>
<li>影响因素：<ul>
<li>Redis 内部的阻塞式操作；</li>
<li>CPU 核和 NUMA 架构的影响；</li>
<li>Redis 关键系统配置；</li>
<li>Redis 内存碎片；</li>
<li>Redis 缓冲区。</li>
</ul>
</li>
<li>阻塞点：<ul>
<li>集合全量查询和聚合操作；</li>
<li>bigkey 删除；删除操作的本质是要释放键值对占用的内存空间，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加。</li>
<li>清空数据库；</li>
<li>AOF 日志同步写；</li>
<li>从库加载 RDB 文件。</li>
</ul>
</li>
<li>Redis4.0以后，Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除（lazy free）以及文件关闭的异步执行。</li>
<li>bigkey 删除时，建议：先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除。</li>
<li>在多核 CPU 架构下，Redis 如果在不同的核上运行，就需要频繁地进行上下文切换，这个过程会增加 Redis 的执行时间，客户端也会观察到较高的尾延迟了。所以，建议在 Redis 运行时，把实例和某个核绑定。为了提升 Redis 的网络性能，我们有时还会把网络中断处理程序和 CPU 核绑定。</li>
<li>过期删除规则：默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：<ol>
<li>采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；</li>
<li>如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。</li>
</ol>
</li>
<li>Redis基线性能：redis-cli 命令提供了–intrinsic-latency 选项，可以用来监测和统计测试期间内的最大延迟。</li>
<li>AOF重写子进程写入量大-&gt;fsync线程阻塞-&gt;主线程阻塞</li>
<li>操作系统的内存 swap（物理机器内存不足）</li>
<li>内存大页（支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行）：Redis在写时复制时，如果采用了内存大页，那么，即使客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。</li>
<li>内存碎片：<ol>
<li>内因：内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</li>
<li>外因：键值对大小不一样和删改操作</li>
<li>查看：mem_fragmentation_ratio 的指标表示的就是 Redis 当前的内存碎片率。大于 1 但小于 1.5是合理的，过高表示碎片过高，过低表示wu里内存不足，导致swap。</li>
<li>碎片清理：Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes。</li>
</ol>
</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>缓存穿透：位运算的布隆过滤器</li>
<li>缓存雪崩：在同一秒内有大量的 key 同时过期，触发了Redis删除规则的第二条，Redis 就会一直删除以释放内存空间。注意，删除操作是阻塞的。解决：过期时间加上一个一定大小范围内的随机数，这样，既保证了 key 在一个邻近时间范围内被删除，又避免了同时过期造成的压力。</li>
<li>数据库和 Redis 缓存的数据一致性</li>
<li>bigkey</li>
<li>hotkey</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/09/09/golang中实现np-frombuffer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/09/09/golang中实现np-frombuffer/" itemprop="url">golang中实现np.frombuffer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-09T17:39:37+08:00">
                2020-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目全部从python转golang了，之前读图片从缓存读算法存储的buffer再用opencv转，在golang下也要实现相同的功能。<br>还遗留一个问题：binary.Read传的数组长度不能从变量获得</p>
<p>python代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = np.frombuffer(imgBuffer, dtype=np.uint8).reshape(data[<span class="string">"shape"</span>])</span><br><span class="line">img =  img[:,:,::<span class="number">-1</span>]</span><br><span class="line">newImg = Image.fromarray(img)</span><br><span class="line">newImg.save(filepath)</span><br></pre></td></tr></table></figure></p>
<p>golang代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   width := <span class="number">1080</span></span><br><span class="line">height := <span class="number">1920</span></span><br><span class="line"><span class="keyword">var</span> imgArr [<span class="number">1080</span>][<span class="number">1920</span>][<span class="number">3</span>]<span class="keyword">uint8</span> <span class="comment">// how to gener array from width&amp;height?</span></span><br><span class="line">buf := bytes.NewReader([]<span class="keyword">byte</span>(imgByte))</span><br><span class="line">err := binary.Read(buf, binary.LittleEndian, &amp;imgArr) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img := image.NewRGBA(image.Rectangle&#123;image.Point&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, image.Point&#123;height, width&#125;&#125;)</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; width; x++ &#123;</span><br><span class="line">	<span class="keyword">for</span> y := <span class="number">0</span>; y &lt; height; y++ &#123;</span><br><span class="line">		cyan := color.RGBA&#123;imgArr[x][y][<span class="number">0</span>], imgArr[x][y][<span class="number">1</span>], imgArr[x][y][<span class="number">2</span>], <span class="number">0xff</span>&#125;</span><br><span class="line">		img.Set(y, x, cyan)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">enc := &amp;png.Encoder&#123;</span><br><span class="line">	CompressionLevel: png.NoCompression,</span><br><span class="line">   &#125;</span><br><span class="line">   f, err := os.Create(filepath)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">err = enc.Encode(f, img)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/04/21/《趣谈网路协议》笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/21/《趣谈网路协议》笔记/" itemprop="url">《趣谈网路协议》笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-21T11:33:16+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol>
<li>概览<img src="/blog/2020/04/21/《趣谈网路协议》笔记/0.jpg"></li>
<li>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</li>
<li>IP 是地址，有定位功能；MAC 是身份证，无定位功能，从硬件角度，保证不同的网卡有不同的标识，通信范围局限在一个子网。</li>
<li>在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。</li>
<li>DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”；DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统，这个在云计算领域大有用处。</li>
</ol>
<h1 id="底层网络协议"><a href="#底层网络协议" class="headerlink" title="底层网络协议"></a>底层网络协议</h1><ol>
<li>MAC 层是用来解决多路访问的堵车问题的；</li>
<li>ARP 是通过广播的方式来寻找目标 MAC 地址的，广播完之后记住一段时间，这个叫作缓存；</li>
<li>交换机是有 MAC 地址学习能力的，结果记录在转发表。</li>
<li>如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2></li>
<li>三次握手<img src="/blog/2020/04/21/《趣谈网路协议》笔记/1.jpg"></li>
<li>四次挥手<img src="/blog/2020/04/21/《趣谈网路协议》笔记/2.jpg">
等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间</li>
<li>TCP 协议使用的也是同样的模式。为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答（cumulative acknowledgment）。</li>
<li>发送端缓存：<img src="/blog/2020/04/21/《趣谈网路协议》笔记/3.jpg"></li>
<li>接收端缓存<img src="/blog/2020/04/21/《趣谈网路协议》笔记/4.jpg"></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/04/20/如何实现一个异步io框架/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/20/如何实现一个异步io框架/" itemprop="url">如何实现一个异步io框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-20T11:42:34+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网卡接收到数据以后"><a href="#网卡接收到数据以后" class="headerlink" title="网卡接收到数据以后"></a>网卡接收到数据以后</h1><h2 id="网卡的基础知识"><a href="#网卡的基础知识" class="headerlink" title="网卡的基础知识"></a>网卡的基础知识</h2><p>网卡本身是有内存的，每个网卡一般都有4k以上的内存，用来发送、接受数据。数据从主内存搬到网卡之后，不是立即就能被发送出去的，而是要先在网卡自身的内存中排队，再按先后顺序发送，同样的，数据从以太网传递到网卡时，网卡也是先把数据存储到自身的内存中，等到收到一帧数据了，再经过中断的方式，告诉CPU把网卡内存的数据读走（现在网卡大都支持DMA方式直接从网卡内存拷贝被内核内存），而读走后的内存，又被清空，再次被用来接收新的数据。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>数据包从外面的网络进入物理网卡。如果目的地址不是该网卡，且该网卡没有开启混杂模式，该包会被网卡丢弃。</li>
<li>网卡将数据包通过DMA的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。</li>
<li>网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了</li>
<li>CPU根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数</li>
<li>驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。</li>
<li>启动软中断。这步结束后，硬件中断处理函数就结束返回了。由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。</li>
<li>经过TCP/IP协议逐层处理。</li>
<li>应用程序通过read()从socket buffer读取数据。</li>
</ol>
<h1 id="socket详细流程"><a href="#socket详细流程" class="headerlink" title="socket详细流程"></a>socket详细流程</h1><h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><h2 id="setblocking"><a href="#setblocking" class="headerlink" title="setblocking"></a>setblocking</h2><h2 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a>backlog</h2><h2 id="syn，accept队列"><a href="#syn，accept队列" class="headerlink" title="syn，accept队列"></a>syn，accept队列</h2><h2 id="accept（）创建新套接字"><a href="#accept（）创建新套接字" class="headerlink" title="accept（）创建新套接字"></a>accept（）创建新套接字</h2><h2 id="协议栈是什么"><a href="#协议栈是什么" class="headerlink" title="协议栈是什么"></a>协议栈是什么</h2><h2 id="粘包是个伪命题"><a href="#粘包是个伪命题" class="headerlink" title="粘包是个伪命题"></a>粘包是个伪命题</h2><h2 id="buffer缓冲区大小"><a href="#buffer缓冲区大小" class="headerlink" title="buffer缓冲区大小"></a>buffer缓冲区大小</h2><h1 id="IO阻塞本质"><a href="#IO阻塞本质" class="headerlink" title="IO阻塞本质"></a>IO阻塞本质</h1><h2 id="读缓存，写缓冲区"><a href="#读缓存，写缓冲区" class="headerlink" title="读缓存，写缓冲区"></a>读缓存，写缓冲区</h2><h2 id="send，recv原理"><a href="#send，recv原理" class="headerlink" title="send，recv原理"></a>send，recv原理</h2><h2 id="满加锁，空解锁"><a href="#满加锁，空解锁" class="headerlink" title="满加锁，空解锁"></a>满加锁，空解锁</h2><h2 id="tcp-ack滑动窗口"><a href="#tcp-ack滑动窗口" class="headerlink" title="tcp ack滑动窗口"></a>tcp ack滑动窗口</h2><h2 id="如何确定recv结构是完整的"><a href="#如何确定recv结构是完整的" class="headerlink" title="如何确定recv结构是完整的"></a>如何确定recv结构是完整的</h2><h2 id="长链接、短连接区别"><a href="#长链接、短连接区别" class="headerlink" title="长链接、短连接区别"></a>长链接、短连接区别</h2><h2 id="socket维护长短连接手段"><a href="#socket维护长短连接手段" class="headerlink" title="socket维护长短连接手段"></a>socket维护长短连接手段</h2><h2 id="keepalive心跳包谁维护"><a href="#keepalive心跳包谁维护" class="headerlink" title="keepalive心跳包谁维护"></a>keepalive心跳包谁维护</h2><h1 id="高并发模型"><a href="#高并发模型" class="headerlink" title="高并发模型"></a>高并发模型</h1><h2 id="fork模型"><a href="#fork模型" class="headerlink" title="fork模型"></a>fork模型</h2><h2 id="进程池-线程池模型"><a href="#进程池-线程池模型" class="headerlink" title="进程池/线程池模型"></a>进程池/线程池模型</h2><h2 id="io复用模型"><a href="#io复用模型" class="headerlink" title="io复用模型"></a>io复用模型</h2><h2 id="惊群、饥饿"><a href="#惊群、饥饿" class="headerlink" title="惊群、饥饿"></a>惊群、饥饿</h2><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><h2 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文"></a>什么是上下文</h2><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h2><h2 id="为什么要上下文切换"><a href="#为什么要上下文切换" class="headerlink" title="为什么要上下文切换"></a>为什么要上下文切换</h2><h2 id="什么时候会上下文切换"><a href="#什么时候会上下文切换" class="headerlink" title="什么时候会上下文切换"></a>什么时候会上下文切换</h2><h1 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h1><h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h2 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h2><h2 id="抢占、协作"><a href="#抢占、协作" class="headerlink" title="抢占、协作"></a>抢占、协作</h2><h1 id="io"><a href="#io" class="headerlink" title="io"></a>io</h1><h2 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h2><h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><h2 id="一个线程如何管理多个fd"><a href="#一个线程如何管理多个fd" class="headerlink" title="一个线程如何管理多个fd"></a>一个线程如何管理多个fd</h2><h1 id="io多路复用"><a href="#io多路复用" class="headerlink" title="io多路复用"></a>io多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><h3 id="水平触发、边缘触发"><a href="#水平触发、边缘触发" class="headerlink" title="水平触发、边缘触发"></a>水平触发、边缘触发</h3><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><h2 id="libevnet"><a href="#libevnet" class="headerlink" title="libevnet"></a>libevnet</h2><h2 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h2><h2 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h2><h1 id="调度器组成"><a href="#调度器组成" class="headerlink" title="调度器组成"></a>调度器组成</h1><ol>
<li>eventLoop</li>
<li>类生成器</li>
<li>Fd生成器的关系</li>
<li>信号处理</li>
<li>文件属性变化</li>
<li>Io可读可写</li>
<li>定时器</li>
<li>periodic</li>
<li>timeout</li>
</ol>
<h1 id="prefork-epoll"><a href="#prefork-epoll" class="headerlink" title="prefork + epoll"></a>prefork + epoll</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/04/16/asyncore实现异步rpc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/16/asyncore实现异步rpc/" itemprop="url">asyncore实现异步rpc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-16T15:29:32+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SERVER 端<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> asyncore</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPCHandler</span><span class="params">(asyncore.dispatcher_with_send)</span>:</span>  <span class="comment"># 客户套接字处理器必须继承 dispatcher_with_send</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sock, addr)</span>:</span></span><br><span class="line">        asyncore.dispatcher_with_send.__init__(self, sock=sock)</span><br><span class="line">        self.addr = addr</span><br><span class="line">        self.handlers = &#123;</span><br><span class="line">            <span class="string">"ping"</span>: self.ping</span><br><span class="line">        &#125;</span><br><span class="line">        self.rbuf = BytesIO()  <span class="comment"># 读缓冲区由用户代码维护，写缓冲区由 asyncore 内部提供</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_connect</span><span class="params">(self)</span>:</span>  <span class="comment"># 新的连接被 accept 后回调方法</span></span><br><span class="line">        print(self.addr, <span class="string">'comes'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_close</span><span class="params">(self)</span>:</span>  <span class="comment"># 连接关闭之前回调方法</span></span><br><span class="line">        print(self.addr, <span class="string">'bye'</span>)</span><br><span class="line">        self.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_read</span><span class="params">(self)</span>:</span>  <span class="comment"># 有读事件到来时回调方法</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            content = self.recv(<span class="number">2</span>)</span><br><span class="line">            <span class="comment"># print('read 2', content)</span></span><br><span class="line">            <span class="keyword">if</span> content:</span><br><span class="line">                self.rbuf.write(content)</span><br><span class="line">            <span class="keyword">if</span> len(content) &lt; <span class="number">1024</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.handle_rpc()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_rpc</span><span class="params">(self)</span>:</span>  <span class="comment"># 将读到的消息解包并处理</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:  <span class="comment"># 可能一次性收到了多个请求消息，所以需要循环处理</span></span><br><span class="line">            self.rbuf.seek(<span class="number">0</span>)</span><br><span class="line">            length_prefix = self.rbuf.read(<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span> len(length_prefix) &lt; <span class="number">4</span>:  <span class="comment"># 不足一个消息</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            length = int.from_bytes(length_prefix, byteorder=<span class="string">'big'</span>) </span><br><span class="line">            body = self.rbuf.read(length)</span><br><span class="line">            <span class="keyword">if</span> len(body) &lt; length:  <span class="comment"># 不足一个消息</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                request = json.loads(body.decode(<span class="string">"utf-8"</span>))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            in_ = request[<span class="string">'in'</span>]</span><br><span class="line">            params = request[<span class="string">'params'</span>]</span><br><span class="line">            handler = self.handlers[in_]</span><br><span class="line">            handler(params)  <span class="comment"># 处理消息</span></span><br><span class="line">            left = self.rbuf.getvalue()[length + <span class="number">4</span>:]  <span class="comment"># 消息处理完了，缓冲区要截断</span></span><br><span class="line">            self.rbuf = BytesIO()</span><br><span class="line">            self.rbuf.write(left)</span><br><span class="line">        self.rbuf.seek(<span class="number">0</span>, <span class="number">2</span>)  <span class="comment"># 将游标挪到文件结尾，以便后续读到的内容直接追加</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, params)</span>:</span></span><br><span class="line">        self.send_result(<span class="string">"pong"</span>, params)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_result</span><span class="params">(self, out, result)</span>:</span></span><br><span class="line">        response = &#123;<span class="string">"out"</span>: out, <span class="string">"result"</span>: result&#125;</span><br><span class="line">        print(<span class="string">"out"</span>,response)</span><br><span class="line">        body = json.dumps(response).encode(<span class="string">"utf-8"</span>)</span><br><span class="line">        length_prefix = len(body).to_bytes(<span class="number">4</span>, byteorder=<span class="string">'big'</span>)</span><br><span class="line">        self.send(length_prefix)  <span class="comment"># 写入缓冲区</span></span><br><span class="line">        self.send(body)  <span class="comment"># 写入缓冲区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span><span class="params">(asyncore.dispatcher)</span>:</span>  <span class="comment"># 服务器套接字处理器必须继承 dispatcher</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port)</span>:</span></span><br><span class="line">        asyncore.dispatcher.__init__(self)</span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.set_reuse_addr()</span><br><span class="line">        self.bind((host, port))</span><br><span class="line">        self.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_accept</span><span class="params">(self)</span>:</span></span><br><span class="line">        pair = self.accept()</span><br><span class="line">        <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            sock, addr = pair</span><br><span class="line">            RPCHandler(sock, addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    RPCServer(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line">    asyncore.loop()</span><br></pre></td></tr></table></figure></p>
<p>CLIENT 端<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clientSocket</span><span class="params">()</span>:</span></span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment"># if sock &lt; 0:</span></span><br><span class="line">        <span class="comment">#         print('socket error')</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">                sock.connect((<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">"exception"</span>)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        message = &#123;<span class="string">"in"</span>:<span class="string">"ping"</span>,<span class="string">"params"</span>:<span class="string">"sha params"</span>&#125;</span><br><span class="line">        message = json.dumps(message).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        encode_bytes = len(message).to_bytes(<span class="number">4</span>, byteorder=<span class="string">'big'</span>) + message</span><br><span class="line">        sock.sendall(encode_bytes)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            data = sock.recv(<span class="number">100</span>)</span><br><span class="line">            print(<span class="string">'received "%s"'</span> %data)</span><br><span class="line"></span><br><span class="line">        sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">        clientSocket()</span><br></pre></td></tr></table></figure></p>
<p>使用epoll实现<br>SERVER端<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建socket对象</span></span><br><span class="line">serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#设置IP地址复用</span></span><br><span class="line">serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#ip地址和端口号</span></span><br><span class="line">server_address = (<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="comment">#绑定IP地址</span></span><br><span class="line">serversocket.bind(server_address)</span><br><span class="line"><span class="comment">#监听，并设置最大连接数</span></span><br><span class="line">serversocket.listen(<span class="number">10</span>)</span><br><span class="line">print(<span class="string">"服务器启动成功，监听IP："</span> , server_address)</span><br><span class="line"><span class="comment">#服务端设置非阻塞</span></span><br><span class="line">serversocket.setblocking(<span class="keyword">False</span>)  </span><br><span class="line"><span class="comment">#超时时间</span></span><br><span class="line">timeout = <span class="number">10</span></span><br><span class="line"><span class="comment">#创建epoll事件对象，后续要监控的事件添加到其中</span></span><br><span class="line">epoll = select.epoll()</span><br><span class="line"><span class="comment">#注册服务器监听fd到等待读事件集合</span></span><br><span class="line">epoll.register(serversocket.fileno(), select.EPOLLIN)</span><br><span class="line"><span class="comment">#保存连接客户端消息的字典，格式为&#123;&#125;</span></span><br><span class="line">message_queues = &#123;&#125;</span><br><span class="line"><span class="comment">#文件句柄到所对应对象的字典，格式为&#123;句柄：对象&#125;</span></span><br><span class="line">fd_to_socket = &#123;serversocket.fileno():serversocket,&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"等待活动连接......"</span>)</span><br><span class="line">        <span class="comment">#轮询注册的事件集合，返回值为[(文件句柄，对应的事件)，(...),....]</span></span><br><span class="line">        events = epoll.poll(timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> events:</span><br><span class="line">            print(<span class="string">"epoll超时无活动连接，重新轮询......"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">"有"</span> , len(events), <span class="string">"个新事件，开始处理......"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> fd, event <span class="keyword">in</span> events:</span><br><span class="line">            socket = fd_to_socket[fd]</span><br><span class="line">            <span class="comment">#如果活动socket为当前服务器socket，表示有新连接</span></span><br><span class="line">            <span class="keyword">if</span> socket == serversocket:</span><br><span class="line">                connection, address = serversocket.accept()</span><br><span class="line">                print(<span class="string">"新连接："</span> , address)</span><br><span class="line">                <span class="comment">#新连接socket设置为非阻塞</span></span><br><span class="line">                connection.setblocking(<span class="keyword">False</span>)</span><br><span class="line">                <span class="comment">#注册新连接fd到待读事件集合</span></span><br><span class="line">                epoll.register(connection.fileno(), select.EPOLLIN)</span><br><span class="line">                <span class="comment">#把新连接的文件句柄以及对象保存到字典</span></span><br><span class="line">                fd_to_socket[connection.fileno()] = connection</span><br><span class="line">                <span class="comment">#以新连接的对象为键值，值存储在队列中，保存每个连接的信息</span></span><br><span class="line">                message_queues[connection]  = queue.Queue()</span><br><span class="line">            <span class="comment">#关闭事件</span></span><br><span class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">                print(<span class="string">'client close'</span>)</span><br><span class="line">                <span class="comment">#在epoll中注销客户端的文件句柄</span></span><br><span class="line">                epoll.unregister(fd)</span><br><span class="line">                <span class="comment">#关闭客户端的文件句柄</span></span><br><span class="line">                fd_to_socket[fd].close()</span><br><span class="line">                <span class="comment">#在字典中删除与已关闭客户端相关的信息</span></span><br><span class="line">                <span class="keyword">del</span> fd_to_socket[fd]</span><br><span class="line">            <span class="comment">#可读事件</span></span><br><span class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">                print(<span class="string">'client in'</span>)</span><br><span class="line">                <span class="comment">#接收数据</span></span><br><span class="line">                data = socket.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    print(<span class="string">"收到数据："</span> , data , <span class="string">"客户端："</span> , socket.getpeername())</span><br><span class="line">                    <span class="comment">#将数据放入对应客户端的字典</span></span><br><span class="line">                    message_queues[socket].put(data)</span><br><span class="line">                    <span class="comment">#修改读取到消息的连接到等待写事件集合(即对应客户端收到消息后，再将其fd修改并加入写事件集合)</span></span><br><span class="line">                    data_handler(fd)</span><br><span class="line">                    <span class="comment"># g1.join()</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#在epoll中注销客户端的文件句柄</span></span><br><span class="line">                    epoll.unregister(fd)</span><br><span class="line">                    <span class="comment">#关闭客户端的文件句柄</span></span><br><span class="line">                    fd_to_socket[fd].close()</span><br><span class="line">                    <span class="comment">#在字典中删除与已关闭客户端相关的信息</span></span><br><span class="line">                    <span class="keyword">del</span> fd_to_socket[fd]</span><br><span class="line">            <span class="comment">#可写事件</span></span><br><span class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">                print(<span class="string">'client out'</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment">#从字典中获取对应客户端的信息</span></span><br><span class="line">                    msg = message_queues[socket].get_nowait()</span><br><span class="line">                <span class="keyword">except</span> queue.Empty:</span><br><span class="line">                    print(socket.getpeername() , <span class="string">" queue empty"</span>)</span><br><span class="line">                    <span class="comment">#修改文件句柄为读事件</span></span><br><span class="line">                    epoll.modify(fd, select.EPOLLIN)</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    print(<span class="string">"发送数据："</span> , data , <span class="string">"客户端："</span> , socket.getpeername())</span><br><span class="line">                    <span class="comment">#发送数据</span></span><br><span class="line">                    socket.send(msg)</span><br><span class="line">    <span class="comment">#在epoll中注销服务端文件句柄</span></span><br><span class="line">    epoll.unregister(serversocket.fileno())</span><br><span class="line">    <span class="comment">#关闭epoll</span></span><br><span class="line">    epoll.close()</span><br><span class="line">    <span class="comment">#关闭服务器socket</span></span><br><span class="line">    serversocket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_handler</span><span class="params">(fd)</span>:</span></span><br><span class="line">    socket = fd_to_socket[fd]</span><br><span class="line">    msg = message_queues[socket].get_nowait()</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">b"ping"</span>:</span><br><span class="line">        message_queues[socket].put(<span class="string">"ok.......pong!"</span>.encode())</span><br><span class="line">        epoll.modify(fd, select.EPOLLOUT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/gx864102252/article/details/82155834" target="_blank" rel="noopener">【RPC-Python】单进程异步模型</a></li>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p05_pack_unpack_large_int_from_bytes.html" target="_blank" rel="noopener">字节到大整数到解包与打包</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/03/31/《MYSQL实战45讲》笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/03/31/《MYSQL实战45讲》笔记/" itemprop="url">《MYSQL实战45讲》笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-31T11:34:28+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><ol>
<li>基本架构 <img src="/blog/2020/03/31/《MYSQL实战45讲》笔记/0.png">
￼</li>
<li>Mysql长链接使内存使用涨得快：<ul>
<li>定期断开长连接。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</p>
</li>
<li><p>change buffer：当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存。</p>
<ul>
<li>何时触发merge：访问这个数据页会；系统有后台线程会定期 merge；在数据库正常关闭（shutdown）的过程中。</li>
</ul>
</li>
<li><p>脏页：当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。脏页什么时候引起flush写入磁盘：</p>
<ul>
<li>InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。</li>
<li>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li>
<li>系统“空闲”的时候。</li>
<li>MySQL 正常关闭的时候。</li>
</ul>
</li>
<li>InnoDB 刷脏页的控制策略：<ul>
<li>innodb_io_capacity 参数会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。</li>
<li>innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。</li>
<li>合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例，不要让它经常接近 75%。</li>
<li>innodb_flush_neighbors=0，只刷自己脏页，不刷邻居。</li>
</ul>
</li>
<li>如果你创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键。</li>
<li>join算法：<ol>
<li>Index Nested-Loop Join（NLJ）：先遍历表 驱动表t1，然后根据从表 t1 中取出的每行数据中的 a 值，去被驱动表 t2 根据索引中查找满足条件的记录。</li>
<li>Block Nested-Loop Join（BNL）：把驱动表 t1 的数据读入线程内存 join_buffer 中，再扫描被驱动表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比（内存操作），满足 join 条件的，作为结果集的一部分返回。<ul>
<li>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。</li>
<li>如果放不下驱动表 t1 的所有数据话，策略就是分段放。</li>
</ul>
</li>
<li>Batched Key Access(BKA)：NLJ的优化，把表 t1 的数据取出来一部分，先放到一个临时内存join_buffer。在用BNL算法处理。</li>
<li>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</li>
<li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li>
<li>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</li>
</ol>
</li>
<li>MySQL 是“边读边发的”，取数据发数据流程：<ol>
<li>获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。</li>
<li>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</li>
<li>如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</li>
<li>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li>
<li>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。如果返回数据很多，使用mysql_use_result。</li>
</ol>
</li>
<li>一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在 99% 以上。（执行 show engine innodb status，查询Buffer pool hit rate）。</li>
<li>InnoDB 内存管理用的是最近最少使用 (Least Recently Used, LRU) 算法。优化：按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。处于 old 区域的数据页，每次被访问的时候，若这个数据页在 LRU 链表中存在的时间超过了 1 秒，才把它移动到链表头部。</li>
<li>自增id不连续原因：<ul>
<li>唯一键冲突</li>
<li>事务回滚</li>
<li>批量插入数据</li>
</ul>
</li>
<li>在生产上，尤其是有批量插入数据（包含的语句类型是 insert … select、replace … select 和 load data 语句）的场景时，从并发插入数据性能的角度考虑，建议设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row</li>
<li>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给 select 的表里扫描到的记录和间隙加读锁。</li>
<li>如果 insert 和 select 的对象是同一个表，则有可能会造成循环写入。</li>
<li>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的 next-key lock(S 锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</li>
<li>主备间事务同步过程：备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。<ul>
<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程。其中 io_thread 负责与主库建立连接。主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ul>
</li>
<li>主备延迟原因：<ul>
<li>备库所在机器的性能要比主库所在的机器性能差</li>
<li>备库的压力大</li>
<li>大事务</li>
<li>备库的并行复制能力</li>
</ul>
</li>
<li>备库并行复制策略（v_5.7.22）：<ul>
<li>COMMIT_ORDER，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
<li>WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ul>
</li>
<li>检测数据库是否正常：<ul>
<li>health_check表</li>
<li>检测performance_schema信息</li>
</ul>
</li>
<li>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant 和 revoke 语句，是不需要随后加上 flush privileges 语句的。flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。</li>
</ol>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ol>
<li>MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</li>
<li>binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的。因为binlog 是不能“被打断的”。一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求。</li>
<li>两阶段提交：数据库备份恢复/扩容一般用全量备份加上应用 binlog 来实现的，数据库奔溃后状态恢复使用redo log，因为两个是独立的逻辑，如果不是两阶段提交，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。<ul>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2></li>
</ul>
</li>
<li>redo log（重做日志）：保证crash-safe，InnoDB的物理日志，记录的是“在某个数据页上做了什么修改”。固定大小，从头开始写，写到末尾就又回到开头循环写。<br>￼   <img src="/blog/2020/03/31/《MYSQL实战45讲》笔记/1.png"></li>
<li>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</li>
<li>InnoDB 用redo log保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</li>
<li>innodb_flush_log_at_trx_commit 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
<li>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</li>
<li>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</li>
<li>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</li>
<li>如果把 innodb_flush_log_at_trx_commit 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次</li>
<li>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。</li>
</ol>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><ol>
<li>binlog（归档日志）：Server层日志。逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。binlog 是可以追加写入的，写完一个文件新增一个文件。sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。</li>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
<li>binlog格式：<ul>
<li>statement：SQL 语句的原文</li>
<li>row：记录操作的完整内容，容易恢复数据。</li>
<li>mixed：MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li>
</ul>
</li>
<li>用 binlog 来恢复数据的标准做法是：用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行。</li>
<li>把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog。</li>
<li>MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ol>
<li>事务支持是在引擎层实现的。数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。 <img src="/blog/2020/03/31/《MYSQL实战45讲》笔记/2.png"></li>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。set autocommit=1，自动提交。</li>
<li>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。start transaction with consistent snapshot会马上启动一个事务。</li>
<li>视图：InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li>
<li>一致性视图：InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”（启动但未提交）的所有事务 ID。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。<img src="/blog/2020/03/31/《MYSQL实战45讲》笔记/2.png">
<ul>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<ul>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
</li>
</ul>
</li>
<li>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。select 语句如果加锁（lock in share mode / for update），也是当前读。</li>
<li>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</li>
<li>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。因为唯一索引更新时需要将数据页读入内存，判断到没有冲突。</li>
<li>收缩表空间：只是 delete 掉表里面不用的数据的话，只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。重建表方法：<ul>
<li>alter table A engine=InnoDB</li>
<li>Online DDL    </li>
</ul>
</li>
<li>count在Inndb需要把数据一行一行地从引擎里面读出来，然后累积计数。按照效率排序的话，count(字段)&lt; count(主键 id)&lt; count(1)~ count(*)。</li>
<li>幻读：指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。幻读仅专指“新插入的行”。在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
</ol>
<h1 id="索引与排序"><a href="#索引与排序" class="headerlink" title="索引与排序"></a>索引与排序</h1><ol>
<li>索引：<ul>
<li>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</li>
<li>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li>
</ul>
</li>
<li>覆盖索引：索引 k 已经“覆盖了”我们的查询需求，不再需要回表查整行记录，我们称为覆盖索引。</li>
<li>最左前缀原则：最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</li>
<li>索引下推：可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>
<li>索引基数采样统计：InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</li>
<li>索引统计信息不准确导致的问题，以用 analyze table 来解决。</li>
<li>字符串创建索引也可用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。前缀的区分度不够好的情况时：<ul>
<li>倒序存储。</li>
<li>使用 hash 字段。</li>
</ul>
</li>
<li>全字段排序：<ul>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li>
<li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li>
<li>对 sort_buffer 中的数据按照字段 name 做快速排序（可能在内存中完成，也可能需要使用外部排序（归并排序算法），这取决于排序所需的内存和参数 sort_buffer_size）；按照排序结果取前 1000 行返回给客户端。</li>
</ul>
</li>
<li>rowid排序：如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法。<ul>
<li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li>
<li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li>
<li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li>
<li>对 sort_buffer 中的数据按照字段 name 进行排序；遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ul>
</li>
<li>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</li>
<li>如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。</li>
<li>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。可能导致全索引扫描。比如隐式类型转换、字符编码转换。</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ol>
<li>全局锁：<ul>
<li>命令是 Flush tables with read lock (FTWRL)。</li>
<li>典型使用场景是，做全库逻辑备份。</li>
</ul>
</li>
<li>表级锁：有两种，表锁、元数据锁。<ul>
<li>元数据锁MDL不需要显式使用，在访问一个表的时候会被自动加上。</li>
<li>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</li>
</ul>
</li>
<li>行锁：<ul>
<li>两阶段锁协议： 在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</li>
</ul>
</li>
<li>死锁：<ul>
<li>设置超时：innodb_lock_wait_timeout</li>
<li>发起死锁检测：innodb_deadlock_detect=on</li>
<li>死锁检测要耗费大量的 CPU 资源</li>
<li>热点行更新导致的性能问题：控制并发度；通过将一行改成逻辑上的多行来减少锁冲突。</li>
</ul>
</li>
<li>间隙锁：产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入间隙锁 (Gap Lock)。<ul>
<li>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</li>
<li>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。</li>
<li>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</li>
<li>你如果把隔离级别设置为读提交的话，就没有间隙锁了。需要把 binlog 格式设置为 binlog_format=row。</li>
</ul>
</li>
<li>加锁规则：<ul>
<li>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
</li>
<li>锁是加在索引上的。</li>
<li>lock in share mode 只锁覆盖索引。for update 系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2020/03/06/json格式化性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/03/06/json格式化性能优化/" itemprop="url">json格式化性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-06T14:15:10+08:00">
                2020-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>语言：python</p>
</li>
<li><p>场景：由于history接口返回图片是base64编码，当limit较大时返回大json字符串。</p>
</li>
<li><p>测试方式：在入口文件加入Profiler</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.middleware.profiler <span class="keyword">import</span> ProfilerMiddleware</span><br><span class="line"></span><br><span class="line">app, socketio = create_app()</span><br><span class="line">app.wsgi_app = ProfilerMiddleware(app.wsgi_app)  </span><br><span class="line">socketio.run(app)</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果：</p>
<img src="/blog/2020/03/06/json格式化性能优化/0.png">
</li>
</ol>
<p>可见在 return jsonify({…})时候，simplejson encode耗时比较久，30ms左右。</p>
<ol start="5">
<li>改进：使用ujson，并覆盖jsonify方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ujson <span class="keyword">as</span> json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jsonify</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args <span class="keyword">and</span> kwargs:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'jsonify() behavior undefined when passed both args and kwargs'</span>)</span><br><span class="line">    <span class="keyword">elif</span> len(args) == <span class="number">1</span>:  <span class="comment"># single args are passed directly to dumps()</span></span><br><span class="line">        data = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = args <span class="keyword">or</span> kwargs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current_app.response_class(</span><br><span class="line">        json.dumps(data) + <span class="string">'\n'</span>,</span><br><span class="line">        mimetype=current_app.config[<span class="string">'JSONIFY_MIMETYPE'</span>]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>性能提升大概2倍，耗时减少至15ms左右.</p>
<img src="/blog/2020/03/06/json格式化性能优化/1.png">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/10/10/JavaScript中并行语言特性/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/10/10/JavaScript中并行语言特性/" itemprop="url">JavaScript中并行语言特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-10T10:59:31+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文整理周爱民在Qcon中《在JavaScript中的并行语言特性》演讲。</p>
<h1 id="JavaScritp中的执行栈"><a href="#JavaScritp中的执行栈" class="headerlink" title="JavaScritp中的执行栈"></a>JavaScritp中的执行栈</h1><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。<br>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。<br><img src="/blog/2019/10/10/JavaScript中并行语言特性/0.png"><br><img src="/blog/2019/10/10/JavaScript中并行语言特性/1.png"><br>Event Loop：当执行栈为空时，从任务队列（RUN JOB）取一个任务执行。再次为空时，再从队列取一个任务，如此循环往复。<br>当一个函数上下文被从执行栈移走时，相当于函数被挂起了。</p>
<h1 id="Promise是如何处理的"><a href="#Promise是如何处理的" class="headerlink" title="Promise是如何处理的"></a>Promise是如何处理的</h1><p>Promise的数据结构：<br><img src="/blog/2019/10/10/JavaScript中并行语言特性/2.png"><br>先看一个hello world例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据就绪，然后做点什么</span></span><br><span class="line"><span class="comment">// Hello world字符串就绪后，然后执行console.log</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">"Hello world"</span>).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure></p>
<p>当then函数，如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aPromise.then(func1,func2)</span><br></pre></td></tr></table></figure></p>
<p>func1、func2 会传入上图 Reaction列表里，两个fun产生的结果值将会产生新的Promise对象，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bPromise = aPromise.then(func1,func2)</span><br></pre></td></tr></table></figure></p>
<p>bPromise与func1 func2无关，只与它们产生的结果有关系。<br>然后Promise.resolve(x) 约等于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line"><span class="comment">// 创建新的置值器</span></span><br><span class="line"><span class="keyword">var</span> [resolve, reject] = ... of p;</span><br><span class="line">resolve(x); <span class="comment">// 相当于 p[[result]] = x;</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></p>
<p>如果x不是一个简单的值，而是一个promise本身,假设 p2 = Promise.resolve(p)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line"><span class="keyword">var</span> [resolve, reject] = ... of p2;</span><br><span class="line">p.then(resolve, reject);  <span class="comment">// resolve(p);</span></span><br><span class="line"><span class="keyword">return</span> p2;</span><br></pre></td></tr></table></figure></p>
<p>上面提到，当函数被走执行栈移走时，函数会被挂起，Promise就是其中一个例子，会导致函数被挂起。Promise在执行栈被初始化后，被扔会任务队列，所以Promise时并行执行的。当数据就绪后，执行栈再次从任务队列调用回来，Promise就被唤起了。</p>
<h1 id="await是如何处理的"><a href="#await是如何处理的" class="headerlink" title="await是如何处理的"></a>await是如何处理的</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">await</span> p;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">p2 = foo();</span><br></pre></td></tr></table></figure>
<p>await与Promise相似，也会导致函数被挂起。<br><img src="/blog/2019/10/10/JavaScript中并行语言特性/4.png"></p>
<ol>
<li>创建一个新的Promise px， 其resolve，reject函数对将用作参数调用p.then(),即Promise.resolve(p)</li>
<li>为px创建一对onFullfilled, onRejected响应函数，使指向当前栈顶上下文。</li>
<li>将响应函数onXXX作为参数调用px.then(),使onXXX函数添加到任务队列。</li>
<li>将当前执行上下文从栈顶移除。<br>至于为什么要创建px，我觉得是为了在onFullfilled函数绑定上下文，参考<a href="https://blog.gcl666.com/2019/06/16/ecma_262_2020_6231_completion_await/" target="_blank" rel="noopener">这里</a></li>
</ol>
<h1 id="语言特性与架构"><a href="#语言特性与架构" class="headerlink" title="语言特性与架构"></a>语言特性与架构</h1><img src="/blog/2019/10/10/JavaScript中并行语言特性/5.png">
<p>在顶层第一行代码使用await会导致主线程被挂起，在ECMA2017创建了工作线程。NodeJs中也有工作线程的概念。主线程与工作线程通过有消息通讯，通过sab共享内存<br><img src="/blog/2019/10/10/JavaScript中并行语言特性/6.png"><br>这种解决方案与分布式环境下并发解决问题是一致的。集群中消息通讯、任务调度、资源管理模型也是语言中底层线程设计思想、解决的问题也是一样的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/09/24/在eventlet的猴子补丁下sslsocket链接失败的问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/09/24/在eventlet的猴子补丁下sslsocket链接失败的问题/" itemprop="url">在eventlet的猴子补丁下sslsocket链接失败的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-24T17:29:25+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>某项目有一个发邮件的需求，由于项目搭建的Web Server使用了eventlet的monkey patch为了多进程下使用websocket。<br>发现在建立ssl socket时会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap_socket() got an unexpected keyword argument &apos;_context&apos;</span><br></pre></td></tr></table></figure></p>
<p>在github查找eventlet的issue。发现<a href="https://github.com/eventlet/eventlet/issues/526" target="_blank" rel="noopener">python 3.7 - wrap_socket() got an unexpected keyword argument ‘_context’</a>这个bug还是open的。</p>
<p>解决：<br>起了新进程，用消息队列通讯，实现发送邮件需求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/09/03/编码器信号类型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/09/03/编码器信号类型/" itemprop="url">编码器信号类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T14:27:27+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一些跟嵌入式相关的工作，涉及增量编码器跟PLC的通讯。</p>
<h1 id="增量编码器的方波脉冲数字信号"><a href="#增量编码器的方波脉冲数字信号" class="headerlink" title="增量编码器的方波脉冲数字信号"></a>增量编码器的方波脉冲数字信号</h1><p>增量编码器的方波脉冲数字信号。增量方波脉冲数字信号也许很简单，但是还是有很多人难以定义并区分清楚，在这么个简单的问题上犯的错误却比比皆是。它实际上决定了编码器信号接收能否很好匹配，并高质量地传输与读取以及信号抗干扰能力。</p>
<p>增量脉冲信号的方波，以电压的高低（开关）电平脉冲式变化，与正余弦模拟量信号不同，方波脉冲信号是数字式开关逻辑信号。在高电平的时候逻辑为1，低电平的时候逻辑为0，这种编码方式称为编码的正逻辑。反之以高电平为“0”低电平为“1”的编码方式为负逻辑。绝大部分编码器默认正逻辑，部分日系编码器（NPN）为负逻辑。</p>
<h1 id="编码器信号类型"><a href="#编码器信号类型" class="headerlink" title="编码器信号类型"></a>编码器信号类型</h1><ol>
<li><p>TTL（transistor transistor logic），TTL信号是数字信号的基础，通常我们采用二进制来表示数据。TTL电平信号规定，+5V等价于逻辑“1”，0V等价于逻辑“0”。这样的数据通信及电平规定方式，被称做TTL（晶体管-晶体管逻辑电平）信号系统。这是计算机处理器控制的设备内部各部分之间通信的标准技术。TTL更多的是用于电路设计，各种芯片单片机的输入输出是TTL信号，它是相对于外部电缆传输的较高电平HTL信号的低电平（5V），定义的数据1（5V）和0（0V）的逻辑电平信号。   </p>
</li>
<li><p>5V差分信号：差分是以两个信号之间的电压差经数学比较处理的概念，在增量脉冲信号中，它表明有每两个信号一组，各自为反相（180度相位差）。5V差分信号是TTL信号每两个信号一组，例如A+对A-，当A+在5V=1的时候，A-在0V=0，逻辑等价与“1”；当180度反相时A+在0V的时候，A-在5V，逻辑等价与“0”。<br>仅仅是在差分信号的定义上，两个信号是平等的可以互换的，互换后逻辑反相。例如编码器的5V差分信号A+与A-是可以互换接线的，互换后相位反180度，也即是信号增量方向与编码器旋转方向反向了，可以用这个方法改变编码器输出方向。<br>差分信号的目的是接收端可以通过差分信号处理消除传输线上的共模干扰。<br>差分信号在双绞线上的传输，抗干扰能力较强。差分的两个信号交替高低电平信号变化，在一对双绞线上配对传输，对外界的电磁场贡献平均为无变化的，外界干扰变化的电磁场对其作用也就达到最小。双绞的“绞”起来的作用，一是同时对于信号电流流向所产生的旋转磁场的反旋，以抵消因电流流向的法拉底原理产生的磁场；另一个是在双绞线配对的两个信号之间的电磁场平衡，防止这两个信号之间串音，尤其是信号频率较高的时候的串音。因此双绞绞起来的节据与设计的需要传输信号的主要频段有关。<br>差分信号以及配对的使用双绞屏蔽线传输，是信号输出与传递的较佳的具有电磁兼容性EMI和抗干扰特性。<br>差分信号的形式不仅仅是5V，不仅仅是方波信号。例如也可以是较高电平的5—30V的HTL信号的含反相差分，HTL-6；或者也可以是正余弦模拟量SINCOS信号，也是差分式的。<br>在5V差分信号的定义上，比TTL多了一点内容，就是两个互为反相信号一组的TTL信号。</p>
</li>
<li><p>长线驱动信号（line driver）：是指发送端与接收端有一对配对的长线驱动器，它们各自有正负两个管脚，当发送端正管脚为高电平往外推送信号电流时，接收端的正管脚为低电平往里拉信号电流（推拉式）。此时电流的方向与信号流的方向一致，视为逻辑1。<br>当发送端正管脚为低电平时，接收端的正管脚为高电平，发送端相当于往里拉电流，电流方向与信号流方向是反的，此时视为逻辑0。在发送端前面送入5VTTL信号，在接收端经过差分后再送出5VTTL的信号。<br>长线驱动信号是有发送端与接收端各有一个长线驱动器配对，在逻辑1和逻辑0时都有信号放大推拉，并也是差分式的。信号走输入单极性TTL~长线驱动（配对的推拉驱动）~接收端差分~单极性TTL输出（进计数器等）。由于有接收端配对的推拉驱动，长线驱动信号传输距离更“长线”。<br>典型的长线驱动器26LS31与26LS32配成一对。为5V 的差分式的。<br>长线驱动是基于一对配对的长线驱动器的偏向于对电子器件的描述，这种传输方式抗干扰强，驱动传输距离远，一般对于编码器的5V差分长线驱动的描述可以传400米（用专业的编码器双绞屏蔽电缆）。<br>长线驱动信号的定义往往取决于配对的长线驱动器件。不局限于5V。<br>长线驱动与5V差分的不同：5V差分有两种可能性：三线制 ，电流回路对0V；长线驱动只有第二种二线制的，电流回路不对0V。</p>
</li>
<li><p>RS422信号：Electronic Industries Association (EIA ) 国际电工协会(EIA) 定义的一个更广泛的信号标准。RS-422标准全称是“平衡电压数字接口电路的电气特性”。接收器采用高输入阻抗和发送驱动器采用差模传输，双绞线。<br>RS422与TTL区别：不一定是5V，可以是5到24V；RS422定义了A+与A-的差模传输方式。<br>RS422与5V差分的区别：信号电压范围更广，对于差分的数学与物理界面、传输的电缆与接口接插头等都有定义。在三线制模式，A+或A-即使在低电平，也可以大于0V。RS422信号的这种基点电压大于0V，可以在传输线上允许有因阻抗而有电压衰减，但差模后仍然能保持大于等于5V的差模电压，因此传输距离可能比长线驱动的更远。其传输距离长度与信号频率有关，在较低的信号频率下最远可传输1000米。</p>
</li>
</ol>
<h1 id="增量编码器中输出电路"><a href="#增量编码器中输出电路" class="headerlink" title="增量编码器中输出电路"></a>增量编码器中输出电路</h1><ol>
<li>集电极开路输出是以输出电路的晶体管发射极作为公共端，并且集电极悬空的输出电路。一般分为NPN集电极开路输出和PNP集电极开路输出</li>
<li>电压输出是在集电极开路输出的电路基础上，在电源间和集电极之间接了一个上拉电阻，使得集电极和电源之间能有一个稳定的电压状态</li>
<li>互补输出是输出上具备NPN和PNP两种输出晶体管的输出电路。根据输出信号的[H]、[L]，2个输出晶体管交互进行[ON]、[OFF]动作，比集电极开路输出的电路传输距离能稍远，也可与集电极开路输入机器（NPN、PNP）连接。</li>
<li>线性驱动输出是采用RS-422标准，用AM26LS31芯片应用于高速、长距离数据传输的输出模式。信号以差分形式输出，因此抗干扰能力更强。输出信号需专门能接收线性驱动输出的设备才能接收。</li>
</ol>
<h1 id="欧系、日系编码器在描述上的不一致不统一"><a href="#欧系、日系编码器在描述上的不一致不统一" class="headerlink" title="欧系、日系编码器在描述上的不一致不统一"></a>欧系、日系编码器在描述上的不一致不统一</h1><p>由于历史原因，先有欧系编码器的TTL信号，然后再有双极性的5V差分，以及基于长线驱动器件配对的长线驱动信号。欧系编码器厂家为原有老客户仍然保持了用TTL信号来表述5V差分信号（长线驱动）。需要注意的是，欧系的TTL目前大部分是默认为5V差分的长线驱动的，但是欧系的TTL也有少部分是5V差分是可以对0V的三线的，也可以是两线的长线驱动。如果是三线的也可以是单独接A+,而可以不接A-(A-悬空)，作为单极性的TTL使用。一些简单设计的设备中，5VTTL电平的ABZ即为这种三线制差分的简化接线方式（只接AB信号），例如我参加的对欧洲塔式积热式太阳能跟踪反射板上供应的增量编码器，就是这种5VTTL的只接AB两根线的，设计要求一样要达到较远距离的传输与抗干扰能力。<br>如果是二线制的，不仅仅必须A+A-都要接上，而且需查产品手册对应寻找到匹配的接收单元与之配对。</p>
<h2 id="欧系编码器的TTL描述有三种可能："><a href="#欧系编码器的TTL描述有三种可能：" class="headerlink" title="欧系编码器的TTL描述有三种可能："></a>欧系编码器的TTL描述有三种可能：</h2><ol>
<li>双极性的5V TTL，接收端封闭配对，接收端单元选型需与发送端查找配对使用（查产品手册），A+A-都必须接。这是最多可能性，或者目前编码器类以TTL表示的几乎默认的模式，目前主要为设备配套提供，较多的是运动控制器与伺服电机编码器匹配。</li>
<li>单极性的5VTTL，，直接的电路板计算机处理器接口，可以只接AB信号。主要为设备电路设计者提供，可直接进入计算机处理器CPU或者计数器芯片。</li>
<li>双极性的5V TTL，三线式对0V的5V电平，接收端开放；它也可以是只接AB单极***，直接连接计算机处理器而省去信号接收芯片，与上述2兼容使用。但是原有差分输出的模式在双绞线上传输一样用差分信号配对使用双绞，同样有部分双绞传输抗干扰的作用。</li>
<li>目前5V差分（欧系仍以TTL表示）大部分用于运动控制器伺服电机编码器，而自动化PLC上用更高电平的HTL信号（非差分式）。在变频器的信号选用上，较佳的应该是HTL-6,即含反相的HTL信号，较高电平的差分信号具有更好的抗变频器干扰特性。</li>
</ol>
<h2 id="日系编码器通常直接以5V-line-driver描述，需查手册与发送端芯片配对使用。"><a href="#日系编码器通常直接以5V-line-driver描述，需查手册与发送端芯片配对使用。" class="headerlink" title="日系编码器通常直接以5V line driver描述，需查手册与发送端芯片配对使用。"></a>日系编码器通常直接以5V line driver描述，需查手册与发送端芯片配对使用。</h2><p>日系编码器更有NPN单极性反逻辑的信号输出，接收端也必须是NPN极性的，它的信号电压公共端在电源的高电平上，信号流开关是在0V上的“有”或“无”的“漏性”电流，信号的“1”和“0”是反的，在逻辑处理时需反向。不建议用上拉电阻临时取电压的不规范接法。</p>
<p>HTL含反相信号-(High Threshold Logic的缩写)是“高阈值逻辑电路”，它的电压阈值9–30V，大于5V TTL，目前较多的是以一对NPN+PNP三极管做成推挽式开关放大电路，兼容集电极开路放大器NPN和PNP。其中PNP接法为正逻辑，以电源0V为公共端；NPN接法为负逻辑，以电源高电平为公共端。HTL信号更多地用于PLC接口，尤其是欧系PLC为编码器标准接口。</p>
<p>HTL信号可以用三线制差分模式（电流回路对0V,取电压差比较差分接收）。同样可以有HTL-6的含反相通道做成差分式接收（A+A-B+B-Z+Z-6通道HTL）。HTL-6可用在变频器接收，因其电平阈值高、差分式可消除变频器及电机的共模干扰，用于变频器接收上抗干扰能力更强。</p>
<h1 id="编码器信号不匹配可能引起的错误："><a href="#编码器信号不匹配可能引起的错误：" class="headerlink" title="编码器信号不匹配可能引起的错误："></a>编码器信号不匹配可能引起的错误：</h1><p>编码器信号不仅仅是有电压差对应，A+A-反相差分也有多种不同，所以并不是看见电压是对的，或者看到是A+A-B+B-含反相的，还是只有ABZ没有反相，就可以判断是不是匹配的可以连接上去了。电压对了ABZ接上去了，哪怕有信号能够读取到，并不代表就是有很好匹配的可以用了，这其中还有多种不匹配引起不良结果的可能性：</p>
<ol>
<li>对0V的关系不同，三线的差分信号电流回路对0V，取电压差比较；二线的差分信号电流回路与0V无关，仅为两个互为差分信号自己构成电流回路的正反电流回路。当设备启动时0V会有波动，如果信号不匹配极易被干扰甚至烧器件。对于有较大型电机在现场，或者有大型设备中的电磁线圈，在启动瞬间的三相绕线不平衡，很有可能会在0V瞬间的波动而发生这种不预期状况。</li>
<li>阻抗匹配的不同，针对于有封闭性配对要求的接收端，编码器脉冲信号的阻抗与信号频率有关，发送与接收阻抗匹配是有预先定义的，尤其是在高频段阻抗的不匹配，将导致在编码器脉冲频率高时的信号丢失的“丢脉”，例如高分辨率编码器或者高速旋转中编码器的频率较高。针对长线驱动有接收端匹配要求的，需查手册配对接收单元。</li>
<li>信号流与电流方向的一致性，如果不匹配将导致读不到信号，甚至烧了器件。编码器如果没有反极性保护和短路保护，这种上去就烧器件的事情常有发生。</li>
<li>抗干扰性能的不同，只有匹配的信号，以及使用双绞屏蔽电缆线，具有更好的抗干扰特性，并信号传输距离能达到标称的长度。双绞电缆仅对差分的匹配的信号有利。单极性的信号或者不匹配的信号没有形成配对，双绞线失去了其设计使用的目的。</li>
<li>日系编码器还有NPN集电极开路式的信号，这类信号接收端也必须是NPN，而且“1”和“0”的逻辑是反的，而不是用上拉电阻临时救急用上去。我不推荐使用这类信号。对于编码器信号输出类别中，NPN信号可以被淘汰了。</li>
<li>目前国内最典型的编码器信号接口不匹配，是欧系PLC（例如西门子PLC）连日系编码器（例如欧姆龙编码器），看似电压与ABZ都对，连上去也能读取信号，但实际上是不匹配的，在频率较高时抗干扰差，容易丢脉冲，甚至容易上电烧器件，应避免这样的连接。其次，是变频器的信号接收应选用差分式含反相的信号，HTL-6含反相6通道因为有更高的电压阈值而更适合在变频器中使用。而目前国内变频器接收的信号很多并不匹配，尤其是选用NPN集电极开路输出信号，因其公共端不在0V，而电机接地是0V的，NPN接法是冲突的不匹配的。</li>
</ol>
<p>参考：<br><a href="http://wap.siemens.com.cn/club/bbs/post/1554368.html" target="_blank" rel="noopener">增量编码器各种输出信号详解（TTL电平、5V差分、长线驱动、RS422等）</a><br><a href="https://zhuanlan.zhihu.com/p/30509923" target="_blank" rel="noopener">回答10个问题，轻松做旋转编码器专家！</a><br><a href="https://zhuanlan.zhihu.com/p/31163840" target="_blank" rel="noopener">谈谈增量型编码器的信号电路输出方式</a><br><a href="https://www.cn.cui.com/blog/comparison-of-common-encoder-output-signals" target="_blank" rel="noopener">常见编码器输出信号比较</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://angelteng.github.io/blog/images/angel.jpg" alt="Angel Teng">
            
              <p class="site-author-name" itemprop="name">Angel Teng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/category/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Angel Teng</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
