---
title: 线程安全
date: 2019-04-15 14:12:31
tags: 
categories: 底层
---
# 原因一：多核CPU的缓存
当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。
按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。
当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。
单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。
![image.png](https://upload-images.jianshu.io/upload_images/14827444-1dc8fc061e339eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。
- 单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。
- 多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。这就是缓存一致性问题。

# 原因二：处理器优化和指令重排
那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。
除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。

# 并发编程
并发编程中的线程安全，必须保证三个条件：
1. 原子性：是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
2. 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 有序性：即程序执行的顺序按照代码的先后顺序执行。

# 内存模型
为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。

# Python中的线程安全
python中由于GIL（Global Interpreter Lock）的存在，即使开了多线程，同一个时间也只有一个线程在执行，但Python不是线程安全的。
GIL:任何python线程在执行之前都需要先获得GIL锁，然后每执行一部分代码，解释器就会自动释放GIL锁，其他线程就可以竞争这个锁，只有得到才能执行程序。对于CPU密集型程序，GIL锁的影响在于，有了它的存在，开启多线程无法利用多核优势，也就是只能用到一个核CPU来运行代码，要想用到多个核只能开启多进程（或者使用不带有GIL锁的解释器）。
1. 使用线程锁： threading.Lock() / threading.RLock()
2. 使用原子操作


参考
[再有人问你Java内存模型是什么，就把这篇文章发给他](https://juejin.im/post/5cad4adc5188251b1f4d87d2)
[列表与队列——谈谈线程安全](https://juejin.im/post/5b129a1be51d45068a6c91d4)



