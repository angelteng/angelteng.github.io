---
title: Redis的性能
date: 2019-04-25 16:54:27
tags:
- Redis
categories: 缓存
---
[Redis的基本数据结构](https://angelteng.github.io/blog/2018/11/22/Redis原理/)

首先，众所周知，Redis是单线程的。

# 有多快？
Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。
![image.png](https://upload-images.jianshu.io/upload_images/14827444-5334ee209b270e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 为什么快？
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用[多路I/O复用模型](https://angelteng.github.io/blog/2019/04/24/I-O操作模式/)，非阻塞IO；
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

# Redis的内存模型
Redis的内存主要包括：对象内存+缓冲内存+自身内存+内存碎片。 
1. 对象内存
    对象内存是Redis内存中占用最大一块，存储着所有的用户的数据。Redis所有的数据都采用的是key-value型数据类型
2. 缓冲内存
    主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区 
    - 客户端缓冲：普通的客户端的连接（大量连接），从客户端（主要是复制的时候，异地跨机房，或者主节点下有多个从节点），订阅客户端（发布订阅功能，生产大于消费就会造成积压） 
    - 复制积压缓冲：2.8版本之后提供的可重用的固定大小缓冲区用于实现部分复制功能，默认1MB，主要是在主从同步时用到。 
    - AOF缓冲区：持久化用的，会先写入到缓冲区，然后根据响应的策略向磁盘进行同步，消耗的内存取决于写入的命令量和重写时间，通常很小。

3. 内存碎片
    目前可选的分配器有jemalloc、glibc、tcmalloc默认jemalloc 
    出现高内存碎片问题的情况：大量的更新操作，比如append、setrange；大量的过期键删除，释放的空间无法得到有效利用 
    解决办法：数据对齐，安全重启（高可用/主从切换）。
4. 自身内存
    主要指AOF/RDB重写时Redis创建的子进程内存的消耗，Linux具有写时复制技术（copy-on-write），父子进程会共享相同的物理内存页，当父进程写请求时会对需要修改的页复制出一份副本来完成写操作。

# 其他
- 单进程多线程模型：MySQL、Memcached、Oracle
- 多进程模型：Oracle

参考：
[Redis是单线程的，但Redis为什么这么快？](https://juejin.im/entry/5b7cfe976fb9a01a13366d95)
[理解Redis的内存](https://juejin.im/entry/5b93ce4d5188255c48349316)