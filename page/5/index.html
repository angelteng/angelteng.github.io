<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Code war of Angel">
<meta property="og:url" content="https://angelteng.github.io/blog/page/5/index.html">
<meta property="og:site_name" content="Code war of Angel">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code war of Angel">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://angelteng.github.io/blog/page/5/">





  <title>Code war of Angel</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code war of Angel</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/05/24/随机森林/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/05/24/随机森林/" itemprop="url">随机森林</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-24T10:59:56+08:00">
                2019-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>随机森林是一种集成算法，集成算法的目标：考虑多个评估器的建模结果，汇总之后得到一个综合的结果，以此来获取比单个模型更好的回归或<br>分类表现。</li>
<li>多个模型集成成为的模型叫做集成评估器(ensemble estimator)，组成集成评估器的每个模型都叫做基评估器 (base estimator)。通常来说，有三类集成算法:装袋法(Bagging)，提升法(Boosting)和stacking。</li>
<li><p>随机森林是一种装袋法模型，装袋法的核心是构建多个独立的评估器，然后对其预测进行平均或多数表决原则决定集成评估器的效果。而提升法中，基评估器是相关的，是按顺序一一构建的。其核心思想是结合弱评估器的力量一次次对难以评估的样本 进行预测，从而构成一个强评估器。提升法的代表模型有Adaboost和梯度提升树。</p>
</li>
<li><p>随机森林的特点：</p>
<ul>
<li>在与其它现有的算法相比，其预测准确率很好</li>
<li>在较大的数据集上计算速度依然很快</li>
<li>不需要降维，算法本身是采取随机降维的</li>
<li>他能处理有缺失值的数据集。算法内部有补缺失值的函数</li>
<li>能给出变量的重要性</li>
<li>能处理imbalanced data set</li>
<li>能给出观测实例间的相似度矩阵，其实就是proximity啦，继而能做clustering 和 location outlier</li>
<li>能对unlabeled data 进行无监督的学习，进行clustering</li>
<li>生成的森林可以保留，应用在新的数据集上</li>
</ul>
</li>
<li><p>控制评估器的参数</p>
<ul>
<li>criterion: 不纯度衡量指标</li>
<li>max_depth: 树最大深度</li>
<li>min_samples_leaf：一个节点在分枝后的每个子节点都必须包含至少min_samples_leaf个训练样本</li>
<li>min_samples_split: 一个分支至少含有min_samples_split个训练样本</li>
<li>max_features： 限制分支时考虑特征个数</li>
<li>min_impurity_decrease: 限制信息增益大小</li>
</ul>
</li>
</ol>
<p>重要参数</p>
<pre><code>- n_estimators： 这是森林中树木的数量，即基基评估器的数量。这个参数对随机森林模型的精确性影响是单调的，n_estimators 越大，模型的效往往越好。但是相应的，任何模型都有决策边界，n_estimators达到一定的程度之后，随机森林 的精确性往往不在上升或开始波动。
</code></pre><p>重要属性</p>
<pre><code>- .estimators_是用来查看随机森林中所有树的列表的。
- oob_score_指的是袋外得分。随机森林为了确保林中的每棵树都不尽相同，所以采用了对训练集进行有放回抽样的 方式来不断组成信的训练集，在这个程中，会有一些数据从来没有被随机挑选到，他们就被叫做“袋外数据”。
- .feature_importances_和决策树中的.feature_importances_用法和含义都一致，是返回特征的重要性。
- predict_proba()： 返回每个测试样本对应的被分到每一类标签的概率
</code></pre><ol start="6">
<li><p>在sklearn中的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛化误差<br><img src="0.png" alt="image.png"><br>当模型太复杂，模型就会过拟合，泛化能力就不够，所以泛化误差大。当模型太简单，模型就会欠拟合，拟合能力就不够，所以误差也会大。只有当模型的复杂度刚刚好的才能够达到泛化误差最小的目标。<br>树模型是天生位于图的右上角的模型，随机森林是以树模型为基础，所以随机森林也是天生复杂度高的模型。随机森林的参数，都是向着一个目标去:减少模型的复杂度，把模型往图像的左边移动，防止过拟合。</p>
</li>
<li><p>参数对误差的影响</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">n_estimators</td>
<td style="text-align:left">提升至平稳，n_estimators↑，不影响单个模型的复杂度</td>
</tr>
<tr>
<td style="text-align:left">max_depth</td>
<td style="text-align:left">有增有减，默认最大深度，即最高复杂度</td>
</tr>
<tr>
<td style="text-align:left">min_samples_leaf</td>
<td style="text-align:left">有增有减，默认最小限制1，即最高复杂度</td>
</tr>
<tr>
<td style="text-align:left">min_samples_split</td>
<td style="text-align:left">有增有减，默认最小限制2，即最高复杂度</td>
</tr>
<tr>
<td style="text-align:left">max_features</td>
<td style="text-align:left">有增有减，默认auto，是特征总数的开平方，位于中间复杂度，max_features↓，模型更简单</td>
</tr>
<tr>
<td style="text-align:left">criterion</td>
<td style="text-align:left">有增有减，一般使用gini</td>
</tr>
</tbody>
</table>
<ol start="9">
<li><p>调参</p>
<ul>
<li><p>学习曲线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">scorel = []</span><br><span class="line">for i in range(0,200,10):</span><br><span class="line">    rfc = RandomForestClassifier(n_estimators=i+1,</span><br><span class="line">                                n_jobs=-1,</span><br><span class="line">                                random_state=90)</span><br><span class="line">    score = cross_val_score(rfc,data.data,data.target,cv=10).mean()</span><br><span class="line">    scorel.append(score)</span><br><span class="line">print(max(scorel),(scorel.index(max(scorel))*10)+1)</span><br><span class="line">plt.figure(figsize=[20,5])</span><br><span class="line">plt.plot(range(1,201,10),scorel)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>网格搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line">param_grid = &#123;&apos;max_depth&apos;:np.arange(1,20,1)&#125;</span><br><span class="line">rfc = RandomForestClassifier(n_estimators=39</span><br><span class="line">                     ,random_state=90</span><br><span class="line">                    )</span><br><span class="line">GS = GridSearchCV(rfc,param_grid,cv=10)</span><br><span class="line">GS.fit(data.data,data.target)</span><br><span class="line">GS.best_params_</span><br><span class="line">GS.best_score_</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>参考：<br><a href="http://edu.cda.cn/course/982/tasks" target="_blank" rel="noopener">菜菜的机器学习sklearn课堂</a><br><a href="http://www.cnblogs.com/litao1105/p/5021747.html" target="_blank" rel="noopener">随机森林算法－Deep Dive</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/05/23/决策树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/05/23/决策树/" itemprop="url">决策树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T17:55:30+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>决策树算法的核心是要解决两个问题: <ul>
<li>如何从数据表中找出最佳节点和最佳分枝? </li>
<li>如何让决策树停止生长，防止过拟合?</li>
</ul>
</li>
<li>流程：<ul>
<li>计算全部特征的不纯度</li>
<li>选取不纯度指标最优的特征来分化</li>
<li>在第一个特征分支下，计算全部特征不纯度</li>
<li>选取不纯度指标最优的特征继续分化</li>
</ul>
</li>
<li><p>sklearn中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import tree</span><br><span class="line">tree.DecisionTreeClassifier:分类树</span><br><span class="line">tree.DecisionTreeRegressor:回归树</span><br><span class="line">tree.export_graphviz:将生成的决策树导出为DOT格式，画图专用</span><br><span class="line">tree.ExtraTreeClassifier:高随机版本的分类树</span><br><span class="line">tree.ExtraTreeRegressor:高随机版本的回归树</span><br></pre></td></tr></table></figure>
</li>
<li><p>重要参数</p>
<ul>
<li>criterion: 不纯度的计算方法（不纯度越低、拟合效果越好）<ul>
<li>entropy 信息熵</li>
<li>gini    基尼系数（默认）</li>
</ul>
</li>
<li>random_state: 随机模式，高纬度下随机性更明显<ul>
<li>None （默认）</li>
<li>任意整数</li>
</ul>
</li>
<li>splitter： 随机选项<ul>
<li>best： 优先选择更重要的特征进行分支</li>
<li>random： 分支随机（防止过拟合）</li>
</ul>
</li>
</ul>
</li>
<li>剪枝参数<br>在不加限制的情况下，一棵决策树会生长到衡量不纯度的指标最优，或者没有更多的特征可用为止，这样的决策树往往会过拟合。<ul>
<li>max_depth: 限制最大深度</li>
<li>min_samples_leaf：一个节点在分枝后的每个子节点都必须包含至少min_samples_leaf个训练样本</li>
<li>min_samples_split: 一个分支至少含有min_samples_split个训练样本</li>
<li>max_features: 限制分枝时考虑的特征个数 </li>
<li>min_impurity_decrease: 限制信息增益的大小</li>
</ul>
</li>
<li>目标权重参数<ul>
<li>class_weight：均衡标签样本的权重</li>
<li>min_ weight_fraction_leaf：基于权重的剪枝参数</li>
</ul>
</li>
<li>确定最优参数：<ul>
<li>学习曲线</li>
</ul>
</li>
</ol>
<p>参考<br><a href="http://edu.cda.cn/course/982/tasks" target="_blank" rel="noopener">菜菜的机器学习sklearn课堂</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/05/23/机器学习链接/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/05/23/机器学习链接/" itemprop="url">机器学习链接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T15:43:22+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>持续更新中….</p>
<ol>
<li>courea上吴恩达的机器学习课程，<a href="https://angelteng.github.io/blog/2019/01/10/机器学习基石学习笔记（一）/">笔记</a></li>
<li><a href="https://wizardforcel.gitbooks.io/pyda-2e/content/14.html" target="_blank" rel="noopener">《利用python进行数据分析》</a>，包含pandas、numpy、matplotlib的使用</li>
<li>sklearn 的使用：<ul>
<li><a href="https://morvanzhou.github.io/tutorials/machine-learning/sklearn/" target="_blank" rel="noopener">通用机器学习 Scikit-learn</a></li>
<li><a href="https://www.bilibili.com/video/av35523476" target="_blank" rel="noopener">菜菜的sklearn课堂</a></li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/30/tensorflow-Web服务部署的坑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/30/tensorflow-Web服务部署的坑/" itemprop="url">tensorflow Web服务部署的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-30T14:13:32+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h1><p>由于需要部署一个基于tensorflow的算法Web服务，使用了uwsgi+flask去部署。<br>uwsgi 使用了多进程，参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 0.0.0.0:5051</span><br><span class="line">chdir = /vagrant/images_check</span><br><span class="line">wsgi-file = /vagrant/images_check/uwsgi_entry.py</span><br><span class="line">callable = app</span><br><span class="line">processes = 4</span><br><span class="line">;harakiri = 30</span><br><span class="line">log-format = %(addr) - %(user) [%(ltime)] &quot;%(method) %(uri) %(proto)&quot; %(status) %(size) &quot;%(referer)&quot; &quot;%(uagent)&quot; %(msecs)ms</span><br></pre></td></tr></table></figure></p>
<p>而算法服务初始化，在入口出使用了queue去初始化，本来的目的是使多个进程都去同一个queue里获取算法服务的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q = Queue() </span><br><span class="line">for i in range(multiprocessing.cpu_count()):</span><br><span class="line">    bqc = CheckImage()</span><br><span class="line">    q.put(bqc)</span><br></pre></td></tr></table></figure></p>
<p>然而发现，运行之后，只有一个进程是能正确运行的，其他进程会阻塞在tf.session.run无法返回</p>
<h1 id="问题跟踪"><a href="#问题跟踪" class="headerlink" title="问题跟踪"></a>问题跟踪</h1><ol>
<li>因为在uwsgi中，工作进程是fork()主进程，获得了一个主进程“拷贝”的内存，所以每个进程都会有一个queue。</li>
<li><p>tensorflow不是进程安全的，所以上面“拷贝”内存的操作，可能倒是tensorflow hang了。<br>在tensorflow issue有类似的提问，<a href="https://github.com/tensorflow/tensorflow/issues/2448" target="_blank" rel="noopener">Session got stuck after fork</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The in-process session (i.e. tf.Session() with no arguments) is not designed to be fork()-safe. If you want to share a set of devices between multiple processes, create a tf.train.Server in one process, and create sessions that connect to that server (with tf.Session(&quot;grpc://...&quot;)) in the other processes.</span><br></pre></td></tr></table></figure>
</li>
<li><p>这篇文章中提到<a href="https://www.cnblogs.com/haolujun/p/9778939.html" target="_blank" rel="noopener">机器学习web服务化实战：一次吐血的服务化之路</a>，的方法，在gunicorn的配置中实例化算法服务，gunicorn可以保证配置文件中的代码只运行一次。同时利用gc.freeze()把截止到当前的所有对象放入持久化区域，不进行回收，从而model占用的内存不会被copy-on-write。但是按照这个方法发现这个实例依然在fork的时候被copy了。</p>
</li>
</ol>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><ol>
<li><p>方案一：改成了在每个进程初始化之后，初始化一个算法服务实例，根据cpu核数配置uwsgi工作进程数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.before_first_request</span><br><span class="line">def first_quest():</span><br><span class="line">    q = Queue()</span><br><span class="line">    for i in range(1):</span><br><span class="line">    bqc = CheckImage()</span><br><span class="line">    q.put(bqc)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案二；<br> 使用redis/mc等中间件。但是有可能有序列化失败的问题。</p>
</li>
<li>使用tensorflow server</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>在gunicron中，配置preload_app = True是可以预加载资源的，但是fork工作进程还是可能出现坑。</p>
<p>参考:<br><a href="https://github.com/tensorflow/tensorflow/issues/2448" target="_blank" rel="noopener">Session got stuck after fork</a><br><a href="https://stackoverflow.com/questions/49227958/how-to-serve-tensorflow-model-using-flaskuwsgi" target="_blank" rel="noopener">How to serve tensorflow model using flask+uwsgi?</a><br><a href="https://www.cnblogs.com/haolujun/p/9778939.html" target="_blank" rel="noopener">机器学习web服务化实战：一次吐血的服务化之路</a><br><a href="http://timd.cn/fork-safety-and-thread-safety/" target="_blank" rel="noopener">fork-safe和thread-safe简介</a><br><a href="https://www.crifan.com/flask_gunicorn_multiple_process_worker_share_data_or_singleton/" target="_blank" rel="noopener">【已解决】Flask的gunicorn中多进程多worker如何共享数据或单实例</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/28/使用多进程服务器gunicorn中多线程问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/28/使用多进程服务器gunicorn中多线程问题/" itemprop="url">使用多进程服务器gunicorn中多线程问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T14:49:15+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>场景：<br>gunicorn + flask<br>gunicorn.conf:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker = 1  # 1个工作进程</span><br><span class="line">worker_class = &quot;geventwebsocket.gunicorn.workers.GeventWebSocketWorker&quot; # 因为使用了websocket</span><br></pre></td></tr></table></figure></p>
<p>在flask 入口处新增了一个子线程做redis的监听工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">def listen_redis():</span><br><span class="line">    while True:</span><br><span class="line">        print(threading.currentThread())</span><br><span class="line">        .....</span><br><span class="line">        print(&apos;get redis&apos;)</span><br><span class="line">t = threading.Thread(target=listen_redis)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure></p>
<p>问题1: 在使用gunicron运行的时候，发现子进程也运行了listen_redis的循环。<br>问题2: 同时由两个线程进行while true的操作，发现有时候一个while true断了再也不工作了。</p>
<h1 id="问题跟踪："><a href="#问题跟踪：" class="headerlink" title="问题跟踪："></a>问题跟踪：</h1><p>在查看gunicron的源码可以发现：<br>/venv/lib/python3.x/site-packages/gunicorn/arbiter.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># line: 575</span><br><span class="line">def spawn_worker(self):</span><br><span class="line">    self.worker_age += 1</span><br><span class="line">    worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,</span><br><span class="line">                               self.app, self.timeout / 2.0,</span><br><span class="line">                               self.cfg, self.log)</span><br><span class="line">    self.cfg.pre_fork(self, worker)</span><br><span class="line">    pid = os.fork()  #是在fork之后出现的“多余的子线程”</span><br><span class="line">    if pid != 0:</span><br><span class="line">        worker.pid = pid</span><br><span class="line">        self.WORKERS[pid] = worker</span><br><span class="line">        return pid</span><br></pre></td></tr></table></figure></p>
<p>通过print(threading.currentThread())可以看到log：<br>主进程的循环打印出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Thread(Thread-2, started 140048726495560)&gt;</span><br></pre></td></tr></table></figure></p>
<p>而子进程的循环打印出来的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;_DummyThread(DummyThread-4, started daemon 140048726495560)&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以确定的是，多了一个不是由threading创建的“虚拟线程”</p>
<p>然后查看gunicron对线程做了什么的时候发现<a href="https://github.com/benoitc/gunicorn/issues/1836" target="_blank" rel="noopener">这个问题</a><br>虽然不是同一个问题，但是这个说到了 monkey_patch对threading做了补丁<br>然后发现在 __init__.py 使用了猴子补丁，是为了websocket，使用了multiple workers时需要共享client connect，详情可以看<a href="https://flask-socketio.readthedocs.io/en/latest/#Using Multiple Workers¶" target="_blank" rel="noopener">flask-socketio文档</a>Using Multiple Workers这一章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If eventlet or gevent are used, then monkey patching the Python standard library is normally required to force the message queue package to use coroutine friendly functions and classes.</span><br></pre></td></tr></table></figure></p>
<p>然后把猴子补丁改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">monkey.patch_all(thread=False)</span><br></pre></td></tr></table></figure></p>
<p>之后，发现“虚拟线程”没有被创建了。<br>但是偶尔会有下面报错，不影响正常功能，暂时不知道原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception ignored in: &lt;module &apos;gevent.threading&apos; from &apos;/demo/venv/lib/python3.5/site-packages/gevent/threading.py&apos;&gt;</span><br><span class="line">AttributeError: module &apos;gevent.threading&apos; has no attribute &apos;_after_fork&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><ol>
<li>首先明确的是，os.fork()创建出来对子进程并不会继承父进程的子线程。在<a href="http://linux.die.net/man/2/fork" target="_blank" rel="noopener">fork(2)-Linux Man Page</a>，中的描述：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The child process is created with a single thread--the one that called fork(). The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of pthread_atfork(3) may be helpful for dealing with problems that this can cause.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>也就是说，在Linux中，fork的时候只复制当前线程到子进程。</p>
<ol start="2">
<li><p>那么，monkey_patch究竟做了什么?<br>monkeypatch修改了threading标准库中的_start_new_thread方法, Condition类等，创建了一个greenlet而不是真正的线程，然后就会在fork的时候被复制了。因此，也可以在gunicron的配置文件中，在on_starting的hook中创建真正的线程。<br>gevent是第三方库，通过greenlet实现协程，其基本思想是：当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br>事实上，gunicron在使用gevent的时候，已经monkey patch了一次，如果patch多次，将会求多次中参数为True的并集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># venv/lib/python3.5/site-packages/gunicorn/workers/ggevent.py:65</span><br><span class="line">def patch(self):</span><br><span class="line">from gevent import monkey</span><br><span class="line">monkey.noisy = False</span><br><span class="line"></span><br><span class="line"># if the new version is used make sure to patch subprocess</span><br><span class="line">if gevent.version_info[0] == 0:</span><br><span class="line">    monkey.patch_all()  # 默认值socket=True, dns=True, time=True, select=True, thread=True, os=True, ssl=True， httplib=False, subprocess=True, sys=False, aggressive=True, Event=False, builtins=True, signal=True</span><br><span class="line">else:</span><br><span class="line">    monkey.patch_all(subprocess=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题2: 从gevent的<a href="http://sdiehl.github.io/gevent-tutorial/" target="_blank" rel="noopener">文档</a>，可以知道，同一时间，只能有一个greenlet在运行，所以如果一个greenlet阻塞了，另一个greentlet就不可能运行，可以通过在while true末尾添加gevent.sleep(0.1)，把控制权（有可能）交给另外一个greenlet。</p>
</li>
</ol>
<h1 id="最终方案："><a href="#最终方案：" class="headerlink" title="最终方案："></a>最终方案：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 方案一：阻塞事件使用线程</span><br><span class="line">from gevent import monkey</span><br><span class="line">monkey.patch_all(thread=False)</span><br><span class="line"></span><br><span class="line">from threading</span><br><span class="line">ta = threading.Thread(target=task)</span><br><span class="line">ta.start</span><br><span class="line"></span><br><span class="line">while true:</span><br><span class="line">    ....</span><br><span class="line">    # gevent.sleep(0.1)</span><br><span class="line"></span><br><span class="line"># 方案二：阻塞事件使用进程</span><br><span class="line">from gevent import monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line">from multiprocess import Process</span><br><span class="line">p = Process(target=task)</span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line">while true:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>参考:<br><a href="https://www.cnblogs.com/liyuan989/p/4279210.html" target="_blank" rel="noopener">谨慎使用多线程中的fork</a><br><a href="https://segmentfault.com/a/1190000013096677" target="_blank" rel="noopener">eventlet 之 monkeypatch 带来的若干兼容性问题实例分析</a><br><a href="https://github.com/benoitc/gunicorn/issues/1056" target="_blank" rel="noopener">monkey.patch_all and gunicorn with more than 1 worker</a><br><a href="http://xiaorui.cc/2016/04/27/源码分析之gevent-monkey-patch_all实现原理/" target="_blank" rel="noopener">源码分析之gevent monkey.patch_all实现原理</a><br><a href="http://www.361way.com/python-gevent/5329.html" target="_blank" rel="noopener">python异步 I/O模块gevent</a><br><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001407503089986d175822da68d4d6685fbe849a0e0ca35000" target="_blank" rel="noopener">gevent-廖雪峰</a><br><a href="https://github.com/Junnplus/blog/issues/9" target="_blank" rel="noopener">gunicorn源码解析</a><br><a href="http://xiaorui.cc/2017/02/16/深入理解uwsgi和gunicorn网络模型上/" target="_blank" rel="noopener">深入理解uwsgi和gunicorn网络模型[上]</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/25/Redis的性能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/25/Redis的性能/" itemprop="url">Redis的性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T16:54:27+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/缓存/" itemprop="url" rel="index">
                    <span itemprop="name">缓存</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://angelteng.github.io/blog/2018/11/22/Redis原理/">Redis的基本数据结构</a></p>
<p>首先，众所周知，Redis是单线程的。</p>
<h1 id="有多快？"><a href="#有多快？" class="headerlink" title="有多快？"></a>有多快？</h1><p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。<br><img src="0.png" alt="image.png"></p>
<h1 id="为什么快？"><a href="#为什么快？" class="headerlink" title="为什么快？"></a>为什么快？</h1><ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>使用<a href="https://angelteng.github.io/blog/2019/04/24/I-O操作模式/">多路I/O复用模型</a>，非阻塞IO；</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<h1 id="Redis的内存模型"><a href="#Redis的内存模型" class="headerlink" title="Redis的内存模型"></a>Redis的内存模型</h1><p>Redis的内存主要包括：对象内存+缓冲内存+自身内存+内存碎片。 </p>
<ol>
<li>对象内存<br> 对象内存是Redis内存中占用最大一块，存储着所有的用户的数据。Redis所有的数据都采用的是key-value型数据类型</li>
<li><p>缓冲内存<br> 主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区 </p>
<ul>
<li>客户端缓冲：普通的客户端的连接（大量连接），从客户端（主要是复制的时候，异地跨机房，或者主节点下有多个从节点），订阅客户端（发布订阅功能，生产大于消费就会造成积压） </li>
<li>复制积压缓冲：2.8版本之后提供的可重用的固定大小缓冲区用于实现部分复制功能，默认1MB，主要是在主从同步时用到。 </li>
<li>AOF缓冲区：持久化用的，会先写入到缓冲区，然后根据响应的策略向磁盘进行同步，消耗的内存取决于写入的命令量和重写时间，通常很小。</li>
</ul>
</li>
<li><p>内存碎片<br> 目前可选的分配器有jemalloc、glibc、tcmalloc默认jemalloc<br> 出现高内存碎片问题的情况：大量的更新操作，比如append、setrange；大量的过期键删除，释放的空间无法得到有效利用<br> 解决办法：数据对齐，安全重启（高可用/主从切换）。</p>
</li>
<li>自身内存<br> 主要指AOF/RDB重写时Redis创建的子进程内存的消耗，Linux具有写时复制技术（copy-on-write），父子进程会共享相同的物理内存页，当父进程写请求时会对需要修改的页复制出一份副本来完成写操作。</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>单进程多线程模型：MySQL、Memcached、Oracle</li>
<li>多进程模型：Oracle</li>
</ul>
<p>参考：<br><a href="https://juejin.im/entry/5b7cfe976fb9a01a13366d95" target="_blank" rel="noopener">Redis是单线程的，但Redis为什么这么快？</a><br><a href="https://juejin.im/entry/5b93ce4d5188255c48349316" target="_blank" rel="noopener">理解Redis的内存</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/24/Nginx-工作原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/24/Nginx-工作原理/" itemprop="url">Nginx 工作原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T15:49:01+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx-模块结构"><a href="#Nginx-模块结构" class="headerlink" title="Nginx 模块结构"></a>Nginx 模块结构</h1><p><img src="0.png" alt="image.png"></p>
<h1 id="Nginx-工作流程"><a href="#Nginx-工作流程" class="headerlink" title="Nginx 工作流程"></a>Nginx 工作流程</h1><p>Nginx的IO通常使用epoll，epoll函数使用了I/O复用模型。</p>
<ol>
<li>master进程一开始根据配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</li>
<li>当一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</li>
<li>监听成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接。即nginx用一个独立的worker进程来处理一个请求，一个worker进程可以处理多个请求。<br>因此，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。采用这种方式的好处：<ul>
<li>节省锁带来的开销。对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查上时，也会方便很多。</li>
<li>独立进程，减少风险。</li>
<li>采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。</li>
<li>在一次请求里无需进程切换。</li>
</ul>
</li>
</ol>
<h1 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h1><ul>
<li>worker_processes：worker角色的进程个数</li>
<li>worker_connections：每一个worker进程能并发处理（发起）的最大连接数（包含所有连接数）</li>
<li>Nginx作为http服务器的时候：max_clients（最大连接数） = worker_processes * worker_connections</li>
<li>Nginx作为反向代理服务器的时候：max_clients（最大连接数） = worker_processes * worker_connections/4 （/4原因：因为浏览器默认会开启2个连接到nginx server，而且nginx还会为每个连接使用fds（file descriptor）从连接池建立connection到upstream后端。）</li>
</ul>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/31196264" target="_blank" rel="noopener">nginx快速入门之基本原理篇</a><br><a href="https://www.jianshu.com/p/6215e5d24553" target="_blank" rel="noopener">理解Nginx工作原理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/24/I-O操作模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/24/I-O操作模式/" itemprop="url">I/O操作模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T15:18:15+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/底层/" itemprop="url" rel="index">
                    <span itemprop="name">底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>流：一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象</li>
<li>I/O操作：流的操作（读/写）。缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</li>
<li>文件描述符fd：是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</li>
</ul>
<h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p><img src="0.png" alt="image.png"></p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>select，poll，epoll都是IO多路复用的机制。一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O。</p>
<p>与阻塞I/O相比，多路复用需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>epoll 操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；//对指定描述符fd执行op操作</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);//等待epfd上的io事件，最多返回maxevents个事件。</span><br></pre></td></tr></table></figure></p>
<p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。)</p>
<p>优点：</p>
<ol>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目。</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ol>
<p>参考：<br><a href="https://blog.51cto.com/yaocoder/888374" target="_blank" rel="noopener">我读过的最好的epoll讲解–转自”知乎“</a><br><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a><br><a href="https://blog.csdn.net/qq_28090573/article/details/50863779" target="_blank" rel="noopener">文件描述符和流的关系？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/22/服务性能分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/22/服务性能分析/" itemprop="url">服务性能分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T14:37:15+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol>
<li>并发数： 也叫并发连接数，指网络设备所能处理的最大会话数量。这里的会话数是指请求-&gt;响应一次会话。</li>
<li>吞吐量：用户请求是由一个个数据包组成，网络设备（防火墙/路由器/交换机）对每个数据包的处理要耗费资源。吞吐量是指在不丢包的情况下单位时间内通过网络设备的数据包数量。</li>
<li>网络层面并发数和吞吐量的关系：<br>并发数x包长度=吞吐量</li>
<li>TPS：Transactions Per Second（每秒事务处理数），指服务器每秒处理的事务次数。一般用于评估数据库、交易系统的基准性能。</li>
<li>QPS：Queries Per Second（查询量/秒），是服务器每秒能够处理的查询次数，例如域名服务器、Mysql查询性能。</li>
<li>QPS（TPS）= 并发数/平均响应时间</li>
</ol>
<p>并发数高，吞吐量不一定高。<br>如果谈的是网络设备，参照：并发数x包长度=吞吐量，吞吐量依赖于并发数和包长度。<br>如果谈的是服务器及完整整体性能，需要明确吞吐量的度量指标，假定以吞吐量以QPS作为度量指标，如果并发数高，但平均响应也很高的话，则QPS可能降低。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>请求响应时间=请求发送耗时+请求解析耗时+请求处理耗时+处理结果返回耗时<br>从性能优化角度出发，就需要我们尽力保持和降低系统的99%RT（即一段时间内请求响应时间从低到高排序，低于99%响应时间的上限边界值(比如容忍值是3s)）的同时，提高单位时间内的处理能力。</p>
<p>step 1:<br>测试指标</p>
<table>
<thead>
<tr>
<th style="text-align:left">指标名称</th>
<th>指标数值</th>
<th>指标说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TPS</td>
<td>100</td>
<td>每秒事务数，很重要的一个指标，衡量系统的处理能力</td>
</tr>
<tr>
<td style="text-align:left">RT</td>
<td>95%、99%、99.99%</td>
<td>百分比请求的响应时间，即n%以内的RT请求响应时间是多少，百分比越高，RT越低，系统越稳定</td>
</tr>
<tr>
<td style="text-align:left">error</td>
<td>0.1%、0.01%</td>
<td>错误率，即可接受的请求失败的占比</td>
</tr>
<tr>
<td style="text-align:left">Cache</td>
<td>90%、95%</td>
<td>缓存命中率：命中率越高，使用缓存的收益越高，系统的性能越好</td>
</tr>
<tr>
<td style="text-align:left">CPU</td>
<td>75%、90%</td>
<td>CPU使用率，一般来说75%是一个阈值，超过85%就需要重点关注</td>
</tr>
</tbody>
</table>
<p>step 2:<br>《jmeter测试指南》</p>
<p>step 3:<br>分析<br><a href="https://www.cnblogs.com/imyalost/p/9611566.html" target="_blank" rel="noopener">常见的性能测试缺陷</a></p>
<p>参考<br><a href="https://www.zhihu.com/question/36734171" target="_blank" rel="noopener">衡量网站性能时，并发数与吞吐量为何要分别考量？</a><br><a href="https://zhuanlan.zhihu.com/p/41189928" target="_blank" rel="noopener">性能测试基础-常见性能指标详解</a><br><a href="https://www.cnblogs.com/imyalost/category/848600.html" target="_blank" rel="noopener">*性能测试</a><br><a href="https://blog.csdn.net/timchen525/article/details/80113749" target="_blank" rel="noopener">JMeter压测上对于并发的认识误区</a><br><a href="https://www.jianshu.com/p/2fff42a9dfcf" target="_blank" rel="noopener">什么是QPS，TPS，吞吐量</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2019/04/15/线程安全/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://angelteng.github.io/blog/images/angel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/15/线程安全/" itemprop="url">线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-15T14:12:31+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/底层/" itemprop="url" rel="index">
                    <span itemprop="name">底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="原因一：多核CPU的缓存"><a href="#原因一：多核CPU的缓存" class="headerlink" title="原因一：多核CPU的缓存"></a>原因一：多核CPU的缓存</h1><p>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。<br>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。<br>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。<br>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。<br><img src="0.png" alt="image.png"></p>
<ul>
<li>单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</li>
<li>单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</li>
<li>多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。这就是缓存一致性问题。</li>
</ul>
<h1 id="原因二：处理器优化和指令重排"><a href="#原因二：处理器优化和指令重排" class="headerlink" title="原因二：处理器优化和指令重排"></a>原因二：处理器优化和指令重排</h1><p>那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。<br>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>并发编程中的线程安全，必须保证三个条件：</p>
<ol>
<li>原子性：是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</li>
<li>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ol>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。</p>
<h1 id="Python中的线程安全"><a href="#Python中的线程安全" class="headerlink" title="Python中的线程安全"></a>Python中的线程安全</h1><p>python中由于GIL（Global Interpreter Lock）的存在，即使开了多线程，同一个时间也只有一个线程在执行，但Python不是线程安全的。<br>GIL:任何python线程在执行之前都需要先获得GIL锁，然后每执行一部分代码，解释器就会自动释放GIL锁，其他线程就可以竞争这个锁，只有得到才能执行程序。对于CPU密集型程序，GIL锁的影响在于，有了它的存在，开启多线程无法利用多核优势，也就是只能用到一个核CPU来运行代码，要想用到多个核只能开启多进程（或者使用不带有GIL锁的解释器）。</p>
<ol>
<li>使用线程锁： threading.Lock() / threading.RLock()</li>
<li>使用原子操作</li>
</ol>
<p>参考<br><a href="https://juejin.im/post/5cad4adc5188251b1f4d87d2" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他</a><br><a href="https://juejin.im/post/5b129a1be51d45068a6c91d4" target="_blank" rel="noopener">列表与队列——谈谈线程安全</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/blog/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><a class="extend next" rel="next" href="/blog/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://angelteng.github.io/blog/images/angel.jpg" alt="Angel Teng">
            
              <p class="site-author-name" itemprop="name">Angel Teng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/category/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Angel Teng</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
