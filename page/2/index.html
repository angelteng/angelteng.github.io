<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Code war of Angel">
<meta property="og:url" content="https://angelteng.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="Code war of Angel">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code war of Angel">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://angelteng.github.io/blog/page/2/">





  <title>Code war of Angel</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code war of Angel</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/12/10/数据结构与算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/10/数据结构与算法/" itemprop="url">数据结构与算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-10T11:14:50+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://upload-images.jianshu.io/upload_images/14827444-6906a9b4cb031ff0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据结构与算法"></p>
<h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><ul>
<li>大O表示法：指代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。</li>
<li>空间复杂度：空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</li>
<li>平均时间复杂度：即加权平均时间复杂度或者期望时间复杂度。</li>
<li>均摊时间复杂度：就是一种特殊的平均时间复杂度，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度低的情况上。</li>
</ul>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ol>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<h4 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h4><p>入门</p>
<ul>
<li>《大话数据结构》</li>
<li>《算法图解》<br>不同编程语言</li>
<li>《数据结构与算法分析：JavaScript(/Python/..)语言描述》<br>经典</li>
<li>《算法》</li>
<li>《算法导论》<br>殿堂级</li>
<li>《计算机程序设计艺术》<br>面试</li>
<li>《编程之美》</li>
<li>《剑指offer》</li>
<li>《编程珠玑》<br>闲暇</li>
<li>《数学之美》</li>
<li>《算法之美》</li>
<li>《算法帝国》</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)，根据下标随机访问的时间复杂度为 O(1)。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。其中，把内存块成为“结点”</p>
<ul>
<li>单链表：每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的的地址（即后续指针 next）<br><img src="https://upload-images.jianshu.io/upload_images/14827444-6108ebed0ec40b0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单链表"><br>头结点记录了链表的基地址，尾节点的指针指向Null空地址。</li>
<li>循环链表：与单链表区别是，尾节点的指针指向头节点。</li>
<li>双向链表：每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针prev指向前一个节点。</li>
</ul>
<h5 id="链表数组性能对比"><a href="#链表数组性能对比" class="headerlink" title="链表数组性能对比"></a>链表数组性能对比</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-9c3def9175edd5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链表数组性能对比"></p>
<ul>
<li>数组使用连续内存空间，可以借助cpu缓存机制，进行预读。<br>[CPU缓存机制]CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。</li>
<li>数据缺点是大小固定，而链表天然支持动态扩容。</li>
</ul>
<h5 id="基于链表LRU缓存淘汰策略"><a href="#基于链表LRU缓存淘汰策略" class="headerlink" title="基于链表LRU缓存淘汰策略"></a>基于链表LRU缓存淘汰策略</h5><ul>
<li>维护一个有序单链表，越靠近尾部节点是越早之前访问</li>
<li>插入数据（新增），缓存未满，将数据插入链表头部</li>
<li>插入数据（已有），缓存未满，将改数据从原来节点迁移到头部节点</li>
<li>插入数据（新增），缓存已满，删除尾节点数据，将新数据插入链表头部</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>后进者先出，先进者后出。（比如垒起来的盘子）</p>
<ul>
<li>动态扩容：均摊复杂度O(1)</li>
<li>函数调用栈：操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”的结构，用来存储函数调用时的临时变量。每进入一个函数，就会讲临时变量作为一个栈帧进入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>应用：</li>
<li>表达式求值：编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。<br><img src="https://upload-images.jianshu.io/upload_images/14827444-b3a444fa7620c278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表达式求值"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">function calculate(val)&#123;</span><br><span class="line">    var cal = val.split(&apos; &apos;);</span><br><span class="line">    var numAry = [];</span><br><span class="line">    var utilAry = [];</span><br><span class="line">    var level = &#123;</span><br><span class="line">        &apos;+&apos;:1,</span><br><span class="line">        &apos;-&apos;:1,</span><br><span class="line">        &apos;*&apos;:2,</span><br><span class="line">        &apos;/&apos;:2</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    var toCalNow = function ()&#123;</span><br><span class="line">        var sum = null;</span><br><span class="line">        console.log(&apos;calnow&apos;,numAry,utilAry);</span><br><span class="line">        for(var n=0,j=0;n&lt;numAry.length,j&lt;utilAry.length;n++,j++)&#123;</span><br><span class="line">            var num1 = numAry[n+1];</span><br><span class="line">            if(n == 0)&#123;</span><br><span class="line">                var num2 = numAry[n];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                var num2 = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            var handler = utilAry[j]</span><br><span class="line">            num2 = parseInt(num2);</span><br><span class="line">            num1 = parseInt(num1);</span><br><span class="line">            switch (handler)&#123;</span><br><span class="line">                case &apos;+&apos;:</span><br><span class="line">                    sum = num1 + num2;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;-&apos;:</span><br><span class="line">                    sum = num1 - num2;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;*&apos;:</span><br><span class="line">                    sum = num1 * num2;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;/&apos;:</span><br><span class="line">                    sum = num1 / num2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&apos;sum&apos;,sum);</span><br><span class="line">        numAry = [sum];</span><br><span class="line">        utilAry = [];</span><br><span class="line">    &#125;</span><br><span class="line">    cal.forEach(v =&gt; &#123;</span><br><span class="line">        if(v == &apos;+&apos; || v == &apos;-&apos; || v == &apos;*&apos; || v == &apos;/&apos;)&#123;</span><br><span class="line">            util = utilAry[0]</span><br><span class="line">            if(!!util &amp; level[v] &lt; level[util])&#123;</span><br><span class="line">                toCalNow();</span><br><span class="line">            &#125;</span><br><span class="line">            utilAry.unshift(v)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            numAry.unshift(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    toCalNow();</span><br><span class="line">    return numAry[0];</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; console.log(calculate(&apos;12 + 2 * 2 - 1 * 2 / 2&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>先进者先出</li>
<li>基于数组顺序队列</li>
<li>基于链表的链式队列</li>
<li><p>循环队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CircularQueue &#123; </span><br><span class="line">    // 数组：items，数组大小：n</span><br><span class="line">    private $items = []; </span><br><span class="line">    private $n = 0;</span><br><span class="line">    private $head = 0;</span><br><span class="line">    private $tail = 0;</span><br><span class="line"></span><br><span class="line">    public function CircularQueue(int capacity)&#123;</span><br><span class="line">        $item = [capacity];  //长度为capacity的数组</span><br><span class="line">        $this-&gt;n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    // 入队</span><br><span class="line">    public function enqueue(String item)&#123;</span><br><span class="line">        //队列满了</span><br><span class="line">        if (($this-&gt;tail + 1) % $this-&gt;n == $this-&gt;head)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;items[$this-&gt;tail] = item;</span><br><span class="line">        $this-&gt;tail = ($this-&gt;tail + 1) % $this-&gt;n;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 出队</span><br><span class="line">    public function dequeue()&#123;</span><br><span class="line">        // 如果head == tail 代表队列为空</span><br><span class="line">        if($this-&gt;head == $this-&gt;tail)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = $this-&gt;items[$this-&gt;head];</span><br><span class="line">        $this-&gt;head = ($this-&gt;head + 1) % n ;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>阻塞队列</p>
</li>
</ul>
<ol>
<li>“消费者”-“生产者”模式</li>
<li>线程池没有空闲线程时，新的任务请求线程资源时，线程池讲新的请求放进数组队列（一定长度）阻塞等待，更多的请求拒绝。</li>
</ol>
<ul>
<li>并发队列<br>加锁</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ul>
<li>关键：找到如何将大问题分解为小问题的规律，并且基于此写出递归公式，然后在推敲出终止条件，最后将递归公式跟终止条件翻译成代码。</li>
<li>警惕堆栈溢出：函数调用的时候，系统栈/虚拟机调用栈空间一般不大，如果递归求解规模很大，调用层次很深，就有可能造成堆栈溢出。</li>
<li>警惕重复计算：可以通过一个数据结构（如散列表）记录已经求过值f(k)数据，以避免重复计算。</li>
<li>警惕死循环：检查环的存在。</li>
<li>空间复杂度高</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><img src="https://upload-images.jianshu.io/upload_images/14827444-336e59b7ec3dcad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="排序算法比较"></p>
<ul>
<li>内存消耗</li>
<li>稳定性：稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序保持不变。</li>
</ul>
<h5 id="冒泡排序-O-n-2"><a href="#冒泡排序-O-n-2" class="headerlink" title="冒泡排序 O(n^2)"></a>冒泡排序 O(n^2)</h5><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</p>
<ul>
<li>原地排序算法</li>
<li>稳定排序算法</li>
<li>时间复杂度：最好O(n)，最差O(n^2)，平均O(n^2)<br><img src="https://upload-images.jianshu.io/upload_images/14827444-422a654258579fb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冒泡排序"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序，a 表示数组</span><br><span class="line">function bubbleSort($a)&#123;</span><br><span class="line">    var $n = $a.length;</span><br><span class="line">    if($n&lt;=1) return;</span><br><span class="line">    for($i=0; $i&lt;$n; $i++)&#123;</span><br><span class="line">        var $flag = false;</span><br><span class="line">        for ($j=0; $j&lt;$n-$i-1; $j++)&#123;</span><br><span class="line">            // 交换</span><br><span class="line">            if($a[$j] &gt; $a[$j+1])&#123; </span><br><span class="line">                var $tmp = $a[$j];</span><br><span class="line">                $a[$j] = $a[$j+1];</span><br><span class="line">                $a[$j+1] = $tmp;</span><br><span class="line">                // 有数据交换，可能可以继续交换</span><br><span class="line">                $flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有交换</span><br><span class="line">            if(!$flag) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="插入排序-O-n-2"><a href="#插入排序-O-n-2" class="headerlink" title="插入排序 O(n^2)"></a>插入排序 O(n^2)</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-ffe00a26c6c852cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入排序"></p>
<ul>
<li>将数组中数据分为已排序空间、未排序空间，初始已排序空间只有数组第一个元素。插入排序核心算法就是取未排序空间元素，在已排序空间中找到合适的位置插入，并保证已排序空间一直有序，重复这个过程，直到未排序空间为空。</li>
<li>原地排序算法</li>
<li>稳定排序算法</li>
<li>时间复杂度：最好O(n)，最坏O(n^2)，平均O(n^2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序 $a表示数组</span><br><span class="line">function insertionSort($a)&#123;</span><br><span class="line">    if($a.length&lt;=1) return;</span><br><span class="line">    for(var i=1;i&lt;$a.length;i++)&#123;</span><br><span class="line">        var value = $a[i];</span><br><span class="line">        var j = i-1;</span><br><span class="line">        for(;j&gt;=0;j--)&#123;</span><br><span class="line">            if(value &lt; $a[j])&#123;</span><br><span class="line">                $a[j+1] = $a[j] // 数据移动</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $a[j+1] = value //移动完再插入数据到位置</span><br><span class="line">    &#125;</span><br><span class="line">    return $a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="选择排序-O-n-2"><a href="#选择排序-O-n-2" class="headerlink" title="选择排序 O(n^2)"></a>选择排序 O(n^2)</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-04400e2ef9f3539b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择排序"></p>
<ul>
<li>类似插入排序，有已排序空间、未排序空间，但是每次会从未排序空间选择最小的元素，插入到已排序空间的的末尾。</li>
<li>原地排序算法</li>
<li>不稳定排序算法</li>
<li>时间复杂度：最好O(n^2)，最坏O(n^2),平均O(n^2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 选择排序 $a表示数组</span><br><span class="line">function selectionSort($a)&#123;</span><br><span class="line">    if($a.length&lt;=1) return;</span><br><span class="line">    for(var i=0;i&lt;$a.length;i++)&#123;</span><br><span class="line">        value = i;</span><br><span class="line">        for(var j=i;j&lt;$a.length;j++)&#123;</span><br><span class="line">            if($a[j]&lt; $a[value])&#123; //找出最小的元素</span><br><span class="line">                value = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = $a[value];</span><br><span class="line">        $a.splice(value,1);  </span><br><span class="line">        $a.splice(i,0,tmp);  //把最小的元素迁移到已排序的末尾</span><br><span class="line">    &#125;</span><br><span class="line">    return $a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="O-n-2-中优选插入排序"><a href="#O-n-2-中优选插入排序" class="headerlink" title="O(n^2)中优选插入排序"></a>O(n^2)中优选插入排序</h5><ul>
<li>与冒泡排序对比：插入排序赋值操作更少，所以性能更优</li>
<li>与选择排序对比：插入排序是稳定性排序算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序</span><br><span class="line">var $tmp = $a[$j];</span><br><span class="line">$a[$j] = $a[$j+1];</span><br><span class="line">$a[$j+1] = $tmp;</span><br><span class="line"></span><br><span class="line">// 插入排序</span><br><span class="line">$a[j+1] = $a[j] // 数据移动</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="归并排序-O-nlogn"><a href="#归并排序-O-nlogn" class="headerlink" title="归并排序 O(nlogn)"></a>归并排序 O(nlogn)</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-4dee99dd055a585a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归并排序"></p>
<ul>
<li>非原地排序算法，由于合并数组需要额外申请空间。</li>
<li>稳定算法</li>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度 O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序，a表示数组</span><br><span class="line">function mergeSort(a)&#123;</span><br><span class="line">    return mergeSort_c(a,0,a.length-1);</span><br><span class="line">&#125;</span><br><span class="line">function mergeSort_c(a,p,r)&#123;</span><br><span class="line">    // 一个数返回自身</span><br><span class="line">    if(r == p)&#123;</span><br><span class="line">        return [a[r]]</span><br><span class="line">    &#125;</span><br><span class="line">    // 两个数对比返回</span><br><span class="line">    if(r-p&lt;=1)&#123;</span><br><span class="line">        return concatSort([a[p]],[a[r]])</span><br><span class="line">    &#125;</span><br><span class="line">    // 多个数再拆分</span><br><span class="line">    else&#123;</span><br><span class="line">        var q = parseInt((p + r) / 2);</span><br><span class="line">        var ary1 = mergeSort_c(a,p,q);</span><br><span class="line">        var ary2 = mergeSort_c(a,q+1,r);</span><br><span class="line">        return concatSort(ary1,ary2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 合并方法</span><br><span class="line">function concatSort(ary1,ary2)&#123;</span><br><span class="line">    var tmp = [];</span><br><span class="line">    while (ary1.length&gt;0 &amp;&amp; ary2.length&gt;0) &#123;</span><br><span class="line">        if(ary1[0]&lt;= ary2[0])&#123;</span><br><span class="line">            tmp.push(ary1[0]);</span><br><span class="line">            ary1.splice(0,1);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            tmp.push(ary2[0]);</span><br><span class="line">            ary2.splice(0,1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ary1.length&gt;0)&#123;</span><br><span class="line">        tmp = tmp.concat(ary1);</span><br><span class="line">    &#125;</span><br><span class="line">    if(ary2.length&gt;0)&#123;</span><br><span class="line">        tmp = tmp.concat(ary2);</span><br><span class="line">    &#125;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="快速排序-O-nlogn-O-n-2"><a href="#快速排序-O-nlogn-O-n-2" class="headerlink" title="快速排序 O(nlogn)~O(n^2)"></a>快速排序 O(nlogn)~O(n^2)</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-8b99c7bdce306fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速排序"></p>
<ul>
<li>如果要排序数组下标p到r之间的一组数据，我们选择p到r之间任意一个数据为pivot（分区点）。遍历p到r之间的数据，将小于pivot的放在左边，大于pivot放在右边。根据分治递归的思想，可以用递归排序p到q-1之间的数据和q+1到r之间的数据，直到区间缩小为1，这样说明所有数据都是有序的。</li>
<li>利用快排实现O(n)找到一个数组的第K大元素。</li>
<li>原地排序算法</li>
<li>不稳定算法</li>
<li>时间复杂度：最好O(nlogn),最差O(n^2)</li>
<li>优化分区点选择：<ol>
<li>三数取中：取头、中、尾三个数，去中间值那个数作为pivot。</li>
<li>随机法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序，A 是数组，n 表示数组的大小 </span><br><span class="line">function quickSort(a)&#123;</span><br><span class="line">    return quickSort_c(a,0,a.length-1);</span><br><span class="line">&#125;</span><br><span class="line">function quickSort_c(a,p,r)&#123;</span><br><span class="line">    if(p&gt;=r)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 分区</span><br><span class="line">    var partition =function (p,r)&#123;</span><br><span class="line">        var pivot = a[r];  // 随便选一个作为pivot</span><br><span class="line">        var i = p;</span><br><span class="line">        for(var j=p;j&lt;r;j++)&#123;</span><br><span class="line">            if(a[j]&lt;pivot)&#123;</span><br><span class="line">                var tmp = a[j];</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">                a[i] = tmp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 交换pivot的位置，放在两个区中间</span><br><span class="line">        var tmp = a[i];</span><br><span class="line">        a[i] = a[r];</span><br><span class="line">        a[r] = tmp;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var q = partition(p,r); </span><br><span class="line">    quickSort_c(a,p,q-1); //整理左边</span><br><span class="line">    quickSort_c(a,q+1,r); //整理右边</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h5 id="归并排序、快速排序对比"><a href="#归并排序、快速排序对比" class="headerlink" title="归并排序、快速排序对比"></a>归并排序、快速排序对比</h5><ul>
<li>都利用分治思想，利用迭代实现。</li>
<li>归并排序：从下到上，先处理子问题再合并。稳定但非原地算法。</li>
<li>快速排序：从上到下，先分区，再处理子问题。不稳定但是原地算法。</li>
</ul>
<h5 id="桶排序-O-n"><a href="#桶排序-O-n" class="headerlink" title="桶排序 O(n)"></a>桶排序 O(n)</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-af8f167c90c54a63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桶排序"></p>
<ul>
<li>核心思想：将要排序的数据分到几个有序的桶里，每个桶的数据再单独进行排序，排完后，再把每个桶里的数据按照顺序依次取出。</li>
<li>时间复杂度：O(n)</li>
<li>数据要求严苛：数据需要容易划分为几个桶，并且有天然的大小顺序，数据在每个桶分布需要均匀。</li>
<li>适合使用在外部排序（数据存储在外部磁盘，数据量大，内存有限，无法将数据全部加载到内存中）。</li>
</ul>
<h5 id="计数排序-O-n"><a href="#计数排序-O-n" class="headerlink" title="计数排序 O(n)"></a>计数排序 O(n)</h5><ul>
<li>桶排序特殊情况，当数据范围不大的时候。</li>
<li>时间复杂度：O(n)<br><img src="https://upload-images.jianshu.io/upload_images/14827444-8f38c9e9dbe01f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计数排序"><br>其中，A数组为原始数组，C数组为，下标对应分数，值为小于等于该分数的数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span><br><span class="line">public void countingSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;= 1) return;</span><br><span class="line"></span><br><span class="line">  // 查找数组中数据的范围</span><br><span class="line">  int max = a[0];</span><br><span class="line">  for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">    if (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]</span><br><span class="line">  for (int i = 0; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算每个元素的个数，放入 c 中</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 依次累加</span><br><span class="line">  for (int i = 1; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-1] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 临时数组 r，存储排序之后的结果</span><br><span class="line">  int[] r = new int[n];</span><br><span class="line">  // 计算排序的关键步骤，有点难理解</span><br><span class="line">  for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">    int index = c[a[i]]-1;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将结果拷贝给 a 数组</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="基数排序-O-n"><a href="#基数排序-O-n" class="headerlink" title="基数排序 O(n)"></a>基数排序 O(n)</h5><p>数据分割成位，按位来排序。</p>
<ul>
<li>数据要求：可分割成独立的位，位之间有递进关系，如果a数据高位比b数据大，那剩下的都不用比较。每一位数据范围不大，要可以用线性排序算法来排序。</li>
<li>时间复杂度：O(n)</li>
</ul>
<h5 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h5><ol>
<li>排序算法对比<br><img src="https://upload-images.jianshu.io/upload_images/14827444-9d4e3a468540ef48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="排序算法对比"></li>
<li>递归过深的堆栈溢出：限制递归深度；在堆上模拟实现函数调用栈，手动模拟递归压栈、出栈过程。</li>
<li>对于小规模数据（百级），O(n^2) 的排序算法并不一定比 O(nlogn) 排序算法执行时间长，可以选择简单、不需要递归的插入排序。</li>
</ol>
<h4 id="二分查找-O-logn"><a href="#二分查找-O-logn" class="headerlink" title="二分查找 O(logn)"></a>二分查找 O(logn)</h4><ol>
<li>每次都跟区间中的中间元素对比，将待查找的区间缩小一半，直到找到要找对元素，或者区间缩小为零。</li>
<li>时间复杂度：O(logn)</li>
<li><p>非递归实现（当数据中不存在重复数据时）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function bsearch(a,value)&#123;</span><br><span class="line">    var low = 0;</span><br><span class="line">    var high = a.length -1;</span><br><span class="line">    // 如果low和high比较大，容易造成溢出，可以使用位运算 low+((high-low)&gt;&gt;1)</span><br><span class="line">    var mid = parseInt(low +(high-low) /2); </span><br><span class="line">    // 注意循环退出条件有相等对情况</span><br><span class="line">    while (low&lt;=high)&#123;</span><br><span class="line">        if(a[mid] == value)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            high = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归实现（当数据中不存在重复数据时）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bsearch(a,value)&#123;</span><br><span class="line">    return bsearchInternally(a,0,a.length-1,value);</span><br><span class="line">&#125;</span><br><span class="line">function bsearchInternally(a,low,high,value)&#123;</span><br><span class="line">    if(low&gt;high) return -1;</span><br><span class="line">    var mid = low+((high-low)&gt;&gt;1);</span><br><span class="line">    if(a[mid] == value)&#123;</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[mid] &lt; value)&#123;</span><br><span class="line">        return bsearchInternally(a,mid+1,high,value);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return bsearchInternally(a,low,mid-1,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局限性</p>
</li>
</ol>
<ul>
<li>依赖顺序表结构（数组），因为数组根据下标查找是O(1)，链表是O(n)。</li>
<li>依赖有序数据，只适合用在一次排序，多次查找对场景。</li>
<li>数据量太少不适合，顺序遍历更快。但是如果数据间比较操作比较耗时，不管数据量太少，推荐使用二分查找。</li>
<li>数据量太大不合适，因为内存不足以存储这个数组。</li>
</ul>
<h5 id="二分查找变形"><a href="#二分查找变形" class="headerlink" title="二分查找变形"></a>二分查找变形</h5><ol>
<li><p>查找第一个值等于给定值对元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function bsearch(a,value)&#123;</span><br><span class="line">    var low = 0;</span><br><span class="line">    var high = a.length -1;</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        var mid = parseInt((low+high)/2);</span><br><span class="line">        if(a[mid]&lt;value)&#123;</span><br><span class="line">            low = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a[mid]&gt;value)&#123;</span><br><span class="line">            high = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            // 如果是第一个元素或者前一个元素不等于value</span><br><span class="line">            if(mid == 0 || a[mid-1] != value)&#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            // 否则要找到的元素还在[low,high-1]区间</span><br><span class="line">            else&#123;</span><br><span class="line">                high = mid -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找最后一个等于给定值的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function bsearch(a,value)&#123;</span><br><span class="line">    var low = 0;</span><br><span class="line">    var high = a.length -1;</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        var mid = parseInt((low+high)/2);</span><br><span class="line">        if(a[mid]&lt;value)&#123;</span><br><span class="line">            low = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a[mid]&gt;value)&#123;</span><br><span class="line">            high = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(mid == a.length-1 || a[mid+1] != value)&#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                low = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找第一个大于等于给定值的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function bsearch(a,value)&#123;</span><br><span class="line">    var low = 0;</span><br><span class="line">    var high = a.length -1;</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        var mid = parseInt((low+high)/2);</span><br><span class="line">        if(a[mid]&lt;value)&#123;</span><br><span class="line">            low = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(mid == 0 || a[mid-1] &lt; value)&#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找最后一个小于等于给定值的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function bsearch(a,value)&#123;</span><br><span class="line">    var low = 0;</span><br><span class="line">    var high = a.length -1;</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        var mid = parseInt((low+high)/2);</span><br><span class="line">        if(a[mid]&gt;value)&#123;</span><br><span class="line">            high = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(mid == a.length-1 || a[mid+1] &gt; value)&#123;</span><br><span class="line">                return mid</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                low = low + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="跳表SkipList-O-logn"><a href="#跳表SkipList-O-logn" class="headerlink" title="跳表SkipList O(logn)"></a>跳表SkipList O(logn)</h4><ol>
<li>链表加多重索引的结构，就是跳表。空间换时间的设计思路。<br><img src="https://upload-images.jianshu.io/upload_images/14827444-4b05c91c11f00e72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳表"></li>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(n)</li>
<li>不更新索引的情况下，动态插入、删除时间复杂度也是O(logn)</li>
<li>更新索引：通过一个随机函数，来决定这个结点插入到哪几级索引中，比如随机函数生成K，将这个结点插入到第一级到第K级这K级索引中。<br><img src="https://upload-images.jianshu.io/upload_images/14827444-3b90ef5d60989f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更新索引"></li>
<li>Redis中使用跳表实现有序集合，相比于红黑树，“根据区间[100,990]查到元素”的操作跳表可以做到O(logn)的时间复杂度定位区间起点，然后在起点往后遍历就可以了，效率比较高。实现比较简单。</li>
</ol>
<h4 id="散列表HashTable-O-k"><a href="#散列表HashTable-O-k" class="headerlink" title="散列表HashTable O(k)"></a>散列表HashTable O(k)</h4><p><img src="https://upload-images.jianshu.io/upload_images/14827444-af0c1327413522f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="散列表"></p>
<ol>
<li>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。通过散列函数将元素的键值映射为下标，将数据存储在数组中对应下标的位置。查询的时候，通过同样的散列函数将键值转为下标，根据下标在数组中取值。</li>
<li>散列函数设计的基本要求：<ul>
<li>散列函数计算的散列值是个非负整数。</li>
<li>如果key1 == key2，那hash(key1) == hash(key2)</li>
<li>如果key1 != key2，那hash(key1) != hash(key2)</li>
</ul>
</li>
<li><p>散列冲突：</p>
<ul>
<li>开放寻址法</li>
<li>链表法，链表长度影响了散列表查询时的时间复杂度<br><img src="https://upload-images.jianshu.io/upload_images/14827444-d3d267c87c6acecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链表法"></li>
</ul>
</li>
<li><p>装载因子= 填入表中元素个数/散列表的长度。装载因子越大，冲突越多，性能下降越多。</p>
</li>
<li>JS中Object基于哈希表，JSON只是约定的字符串格式，可以转为JavaScript的object。<a href="https://lz5z.com/JavaScript-Object-Hash/" target="_blank" rel="noopener">更多</a></li>
<li>加密中应用：哈希算法就是将任意数据转换成一定范围数据的算法，这种算法的副作用就是会产生冲突。但是在快速查找中出现的副作用，却是加密功能中的核心，因为有冲突，所以从结果就无法逆推出输入值，这样就实现了数据的单向加密。而输入数据的变化却又会影响到哈希串的值，所以我们可以用哈希串来进行数据的校验。</li>
</ol>
<h5 id="工业级别散列表"><a href="#工业级别散列表" class="headerlink" title="工业级别散列表"></a>工业级别散列表</h5><ol>
<li>要求：</li>
</ol>
<ul>
<li>支持快速查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多内存空间；</li>
<li>性能稳定，极端情况下，散列表性能不会退化到无法接受的情况</li>
</ul>
<ol start="2">
<li>设计要点：</li>
</ol>
<ul>
<li>设计合适的散列函数：生成的值随机、分布均匀。</li>
<li>定义装在因子阈值，设计动态扩容策略；<br>  避免低效（一次性）的扩容：当装载因子达到阈值时，只申请新空间，不迁移数据。当有一个新数据插入时，将新数据插入到新的散列表中，并从老数据拿出一个迁移到新散列表。迁移期间如果需要查询，先从新散列表查询，没有再从旧散列表查询。</li>
<li>选择合适的散列冲突解决方法；<br>  开放寻址法：适合数据量小，装载因子小（&lt;1)的时候。<br>  链表法：大装在因子容忍度高，适合存储大对象（此时指针占用内存可以忽略）、大数据量。</li>
</ul>
<h5 id="散列表与链表结合"><a href="#散列表与链表结合" class="headerlink" title="散列表与链表结合"></a>散列表与链表结合</h5><p>散列表支持非常高效插入、删除、查找，但是顺序是打乱的，没有办法按照某种顺序快速遍历，将链表结合使用可以解决这个问题。</p>
<ol>
<li>LRU淘汰算法<br><img src="https://upload-images.jianshu.io/upload_images/14827444-93487d1af78a5ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LRU淘汰算法"></li>
</ol>
<ul>
<li>散列表+双向链表存储结构，时间复杂度O(1)。</li>
<li>查找：散列表中时间复杂度接近O(1)，找到数据后，迁移到双向链表尾部。</li>
<li>删除：借助散列表，在O(1)复杂度中找到要删除的结点，双向链表通过O(1)找到前驱结点。</li>
<li>插入：先查找这个数据是否在缓存中，如果在，迁移到双向链表尾部，如果不在，如果缓存满了，将双向链表头部结点删除，再将数据放在双向链表尾部，如果缓存没满，直接将数据放在双向链表尾部。</li>
</ul>
<ol start="2">
<li>Redis有序集合</li>
</ol>
<ul>
<li>散列表+跳表</li>
<li>按照分值将对象组织成跳表，在按键值构建一个散列表。</li>
</ul>
<ol start="3">
<li>Java LinkedHashMap</li>
</ol>
<h5 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h5><ol>
<li>要求：<ul>
<li>从哈希值不能反向推导出原始数据。</li>
<li>输入的数据不同，哈希值不同。</li>
<li>散列冲突概率很小。</li>
<li>执行效率要高。 </li>
</ul>
</li>
<li>应用：<ul>
<li>安全加密：MD5、SHA、DES、AES<br>  字典攻击：加盐</li>
<li>唯一标识：从图片二进制编码取某一些字节，进行加密，使用加密值代表这样图片的唯一标识</li>
<li>数据校验：文件切割，分别对各个文件求哈希值，用户下载完各个切割文件后，先校验哈希值是否一致，以检查文件是否被篡改/完整。</li>
<li>散列函数</li>
</ul>
</li>
<li>区块链：区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。区块头保存着[自己区块体]和[上一个区块头]的哈希值。因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。</li>
</ol>
<h5 id="哈希算法在分布式系统中应用"><a href="#哈希算法在分布式系统中应用" class="headerlink" title="哈希算法在分布式系统中应用"></a>哈希算法在分布式系统中应用</h5><ol>
<li>负载均衡<ul>
<li>实现会话粘滞的负载均衡算法：通过哈希算法，将客户端ip/用户session id进行计算，将哈希值与服务器数量进行取模计算，得到的值就是服务器编号。</li>
</ul>
</li>
<li>数据分片<ul>
<li>数据量非常大的时候，将数据进行分片分开存储到n台服务器上，将数据进行哈希计算，取模，获得服务器编号。</li>
</ul>
</li>
<li>分布式存储<ul>
<li>分布式缓存：<a href="https://zh.wikipedia.org/wiki/一致哈希" target="_blank" rel="noopener">一致性哈希算法</a>，<a href="https://www.sohu.com/a/158141377_479559" target="_blank" rel="noopener">一致性算法图解</a><br>假设k台机器，数据范围[0~MAX]，分成m（m&gt;&gt;k)个区间，每个机器负责m/k个小区间。当有新机器加入的时候，将某几个小区间的数据从原来服务器迁移到新服务器中。</li>
</ul>
</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ol>
<li>概念<br><img src="https://upload-images.jianshu.io/upload_images/14827444-ee545ef13dcf95de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉树"><ul>
<li>节点的高度：结点到叶子结点的最长路径</li>
<li>节点的深度：根节点到这个结点所经历边的个数</li>
<li>节点的层级：结点的深度+1</li>
<li>树的高度：根节点的高度</li>
</ul>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/14827444-c52ab6536ec5111d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉树的类型"></p>
<pre><code>- 满二叉树：编号2，叶子节点都在最底层，除叶子节点外，每个节点都有左右两个子节点。
- 完全二叉树：编号3，叶子节点都在最下层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。
</code></pre><ol start="2">
<li><p>存储二叉树</p>
<ul>
<li>链表存储法<br><img src="https://upload-images.jianshu.io/upload_images/14827444-f1b83bcd2e607e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链表存储法"></li>
<li>顺序存储法<br><img src="https://upload-images.jianshu.io/upload_images/14827444-bd584d1f79d708c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序存储法"><br>如果是完全二叉树，数组存储是最节省内存的方法。</li>
</ul>
</li>
<li><p>二叉树的遍历 O(n)<br><img src="https://upload-images.jianshu.io/upload_images/14827444-1cb04fef37e82f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉树的遍历"></p>
<ul>
<li>前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li>
<li>中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li>
<li>后序遍历：对于树中的任意节点来说，线打印它的左子树，然后打印右子树，最后打印它本身。</li>
<li>按层遍历<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 前序遍历</span><br><span class="line">function preOrder(root) &#123;</span><br><span class="line">  if (root == null) return;</span><br><span class="line">  console.log(root.val) </span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中序遍历</span><br><span class="line">function inOrder(root) &#123;</span><br><span class="line">  if (root == null) return;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  console.log(root.val) </span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 后序遍历</span><br><span class="line">function postOrder(root) &#123;</span><br><span class="line">  if (root == null) return;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  console.log(root.val) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="二叉查找树-O-logn"><a href="#二叉查找树-O-logn" class="headerlink" title="二叉查找树 O(logn)"></a>二叉查找树 O(logn)</h5><ol>
<li>要求：对于树中任意一个节点，其左子树的值都要小与这个节点的值，右子树的值都要大于这个节点的值。<br> 平衡时间复杂度：O(logn)</li>
<li><p>二叉查找树的查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function treeSearch(tree,value)&#123;</span><br><span class="line">    if(tree.value === value)&#123;</span><br><span class="line">        return tree.value;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(tree.value&lt;value &amp;&amp; tree.right)&#123;</span><br><span class="line">        return treeSearch(tree.right,value);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(tree.value&gt;value &amp;&amp; tree.left)&#123;</span><br><span class="line">        return treeSearch(tree.left,value);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树插入操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 假设插入的数据在叶子节点上</span><br><span class="line">function treeInsert(tree,value)&#123;</span><br><span class="line">    var p = tree;</span><br><span class="line">    while (p!=null)&#123;</span><br><span class="line">        if(p.value === value)&#123;</span><br><span class="line">            return &apos;repeat&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p.value &lt; value)&#123;</span><br><span class="line">            if(!p.right)&#123;</span><br><span class="line">                p.right = &#123;value: value&#125;;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p.value &gt; value)&#123;</span><br><span class="line">            if(!p.left)&#123;</span><br><span class="line">                p.left = &#123;value: value&#125;;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树删除操作</p>
<ul>
<li>如果该节点没有子节点，删除该节点，并将父节点指向Null。</li>
<li>如果该节点有一个子节点，删除该节点，并将父节点指向子节点。</li>
<li>如果该节点有两个及以上子节点，删除该节点，并将右子树中最小节点替换到该位置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function treeDelete(tree,value)&#123;</span><br><span class="line">    var p = tree;</span><br><span class="line">    var pp = null; // 父节点</span><br><span class="line">    while (p!=null &amp;&amp; p.value!= value)&#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        if(value &gt; p.value)&#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( p == null)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有子节点</span><br><span class="line">    if(!p.left &amp;&amp; !p.right)&#123;</span><br><span class="line">        if(pp.right == p)&#123;</span><br><span class="line">            delete pp.right;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            delete pp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 有一个子节点</span><br><span class="line">    else if(!p.left || !p.right)&#123;</span><br><span class="line">        var child = p.left? p.left:p.right;</span><br><span class="line">        if(pp.right == p)&#123;</span><br><span class="line">            pp.right = child;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            pp.left = child;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 有两个及以上子节点</span><br><span class="line">    else&#123;</span><br><span class="line">        //找右子树中的最小值</span><br><span class="line">        minP = p.right; </span><br><span class="line">        minPP = p;</span><br><span class="line">        while(minP.left !=null)&#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.value = minP.value;</span><br><span class="line">        delete minPP.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>快速查找最大、最小节点、前驱节点、后继结点</p>
</li>
<li>中序遍历查找二叉树，可以输出有序的数据，时间复杂度是O(n)</li>
<li>支持重复数据的二叉查找树：<ul>
<li>方法一：二叉查找树每个节点不止存储一个数据，存储一个链表，或者是动态扩容的数据。</li>
<li>方法二：每个节点只存储一个数据，如果重复，将这个值放在右子树，当作大于这个节点处理。查找时，查到值相同节点不停止查找，继续在右子树中查找，知道找到叶子节点。删除时，先找到所有节点，再按正常删除操作处理。</li>
</ul>
</li>
<li>与散列表对比：<ul>
<li>散列表数据是无序的，如需要有序的数据，先排列；二叉查找树只需要中序遍历，可以在O(n)时间复杂度内，输出有序的数据序列。</li>
<li>散列表扩容需要耗时比较久，遇到散列冲突时，性能不稳定；平衡二叉树的性能稳定，时间复杂度在O(logn)。</li>
<li>散列表查找操作时间时常数级，但因为哈希冲突存在，这个常量不一定比logn小，加上哈希函数的耗时。</li>
<li>散列表的构造比二叉查找树要复杂；平衡二叉查找树只需要考虑平衡性这一个问题。</li>
</ul>
</li>
</ol>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p><img src="https://upload-images.jianshu.io/upload_images/14827444-c0b6e9ab694ca38c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="红黑树"><br>红黑树是一种性能非常稳定的平衡二叉树，它是为了解决普通二叉树在数据更新中，复杂度退化的问题产生的，红黑树的高度近似log2n，所以它是近似平衡，查找、插入、删除的时间复杂度都是O(logn)。</p>
<ol>
<li>要求<ul>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色空节点，也就是说叶子节点不存储数据</li>
<li>任何相邻节点不同时为红色，也就是说，红色节点是被黑色节点隔开</li>
<li>每个节点，从该节点到达其可达叶子节点所经过的所有路径，经过的黑色节点的数目相同</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><img src="https://upload-images.jianshu.io/upload_images/14827444-e0d2f799bf77eb78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左旋&amp;右旋"><br>左旋：围绕某个节点的左旋<br>右旋：围绕某个节点的右旋</li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li>插入操作的平衡调整：<br>  规定：插入的节点必须是红色的，而且二叉查找树中新插入的节点都是放在叶子节点上。<ol>
<li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li>
<li>除此外的情况需要左右旋转、改变颜色来满足规定。</li>
</ol>
</li>
<li>case1: 如果关注节点是 a，它的叔叔节点 d 是红色<br><img src="https://upload-images.jianshu.io/upload_images/14827444-93258d273272c9c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="case1"><ol>
<li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色</li>
<li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li>
<li>关注节点变成 a 的祖父节点 c；</li>
<li>跳到 CASE 2 或者 CASE 3。</li>
</ol>
</li>
<li>case2: 如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a是其父节点 b 的右子节点<br><img src="https://static001.geekbang.org/resource/image/44/ad/4480a314f9d83c343b8adbb28b6782ad.jpg" alt="case2"><ol>
<li>关注节点变成节点 a 的父节点 b；</li>
<li>围绕新的关注节点b 左旋；</li>
<li>跳到case3.</li>
</ol>
</li>
<li>case3: 如果关注节点是 a，它的叔叔节点d是黑色，关注节点a 是其父节点b的左子节点<br><img src="https://static001.geekbang.org/resource/image/04/12/04650d9470b1e67899f5b8b7b8e33212.jpg" alt="case3"><ol>
<li>围绕关注节点 a 的祖父节点 c 右旋;</li>
<li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</li>
<li>调整结束。</li>
</ol>
</li>
</ul>
</li>
<li>删除<ul>
<li>Step1: 针对删除节点初步调整，保证整个红黑树在删除这个节点后，依然满足“每个节点，从该节点到达其可达叶子节点所经过的所有路径，经过的黑色节点的数目相同”。<ol>
<li>case1: 如果要删除的节点是 a，它只有一个子节点 b<br><img src="https://static001.geekbang.org/resource/image/a6/c3/a6c4c347b7cbdf57662bab399ed36cc3.jpg" alt="case1"><ul>
<li>删除节点 a，并且把节点 b 替换到节点 a 的位置</li>
<li>节点a只能是黑色，节点b只能是红色。在case1中，将节点b改成黑色。</li>
<li>不需要二次调整</li>
</ul>
</li>
<li>case2: 如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是a的右子节点c<br><img src="https://static001.geekbang.org/resource/image/48/4e/48e3bd2cdd66cb635f8a4df8fb8fd64e.jpg" alt="case2"><ul>
<li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点a的位置。</li>
<li>把节点c 的颜色设置为节点a的颜色</li>
<li>如果节点c是黑色，为了不违反最后一条定义，给节点c的右子节点d增加一个黑色。</li>
<li>此时关注节点变成d ，进行二次调整。</li>
</ul>
</li>
<li>case3: 如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的的后继节点不是右子节点<br><img src="https://static001.geekbang.org/resource/image/b9/29/b93c1fa4de16aee5482424ddf49f3c29.jpg" alt="case3"><ul>
<li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照case1</li>
<li>将节点 a 替换成后继节点 d</li>
<li>把节点 d 的颜色设置为跟节点 a 相同的颜色</li>
<li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点d的右子节点c多加一个黑色</li>
<li>此时关注节点变成c，进行二次调整。</li>
</ul>
</li>
</ol>
</li>
<li>Step2: 二次调整，以满足“即不存在相邻的两个红色节点“<ol>
<li>case1: 如果关注节点是 a，它的兄弟节点 c 是红色的<br><img src="https://static001.geekbang.org/resource/image/ac/91/ac76d78c064a2486e2a5b4c4903acb91.jpg" alt="case1"><ul>
<li>围绕关注节点 a 的父节点 b 左旋</li>
<li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色</li>
<li>关注节点不变</li>
<li>继续从四种情况中选择适合的规则来调整</li>
</ul>
</li>
<li>case2: 如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c的左右子节点 d、e 都是黑色的<br><img src="https://static001.geekbang.org/resource/image/ec/ec/eca118d673c607eb2b103f3476fb24ec.jpg" alt="case2"><ul>
<li>将关注节点 a 的兄弟节点 c 的颜色变成红色</li>
<li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色/黑色</li>
<li>给关注节点 a 的父节点b增加一个黑色</li>
<li>关注节点从 a 变成其父节点 b</li>
<li>继续从四种情况中选择适合的规则来调整</li>
</ul>
</li>
<li>case3: </li>
</ol>
</li>
</ul>
</li>
</ol>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/68976?code=dywldOC0YOf1iEE9qMZlHT8Yv8MdAXs9bSGuF1qs7mQ%3D" target="_blank" rel="noopener">https://time.geekbang.org/column/article/68976?code=dywldOC0YOf1iEE9qMZlHT8Yv8MdAXs9bSGuF1qs7mQ%3D</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/12/06/hmac加密算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/06/hmac加密算法/" itemprop="url">hmac加密算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T11:42:51+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>密钥散列消息认证码(Keyed-hash message authentication code)<br>它是一种通过特别计算方式之后产生的消息认证码（MAC），使用密码散列函数，同时结合一个加密密钥。它可以用来保证数据的完整性，同时可以用来作某个消息的身份验证。</p>
<p>使用方法（Python)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line"># 传入的key和message都是bytes类型</span><br><span class="line">message = b&apos;Hello, world!&apos;</span><br><span class="line">key = b&apos;secret&apos;</span><br><span class="line">h = hmac.new(key, message, digestmod=&apos;MD5&apos;)</span><br><span class="line"># 如果消息很长，可以多次调用h.update(msg)</span><br><span class="line">h.hexdigest()</span><br><span class="line"># output: &apos;fa4ee7d173f2d97ee79022d1a7355bcf&apos;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://pythoncaff.com/docs/pymotw/hmac-cryptographic-message-signing-and-verification/134" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/12/04/利用Tensorflow简单线性拟合实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/04/利用Tensorflow简单线性拟合实践/" itemprop="url">利用Tensorflow简单线性拟合实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-04T11:39:14+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn import datasets</span><br><span class="line">from sklearn.model_selection import train_test_split </span><br><span class="line"></span><br><span class="line">print(tf.__version__)</span><br><span class="line"></span><br><span class="line"># 流程：</span><br><span class="line"># 1. 数据处理</span><br><span class="line"># 2. 选择模型</span><br><span class="line"># 3. 训练模型</span><br><span class="line"># 4. 模型评估</span><br><span class="line"># 5. 调整参数</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris() # sk自带了的鸢尾花数据集（含有三种鸢尾花，有四种特征数据）</span><br><span class="line"></span><br><span class="line"># 载入数据，划分训练/测试集（20%）</span><br><span class="line">train_X, test_X, train_y, test_y = train_test_split(iris.data, iris.target, test_size = 0.2, random_state = 0)</span><br><span class="line"></span><br><span class="line"># 所有特征都是实数值</span><br><span class="line"># shape是特征值数量</span><br><span class="line">feature_name = &quot;flower_features&quot;</span><br><span class="line">feature_columns = [tf.feature_column.numeric_column(feature_name, </span><br><span class="line">                                                    shape=[4])]</span><br><span class="line"></span><br><span class="line">classifier = tf.estimator.LinearClassifier(</span><br><span class="line">    feature_columns=feature_columns,</span><br><span class="line">    n_classes=3,</span><br><span class="line">    model_dir=&quot;/tmp/iris_model&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输入函数，讲导入的数据转换为TensorFlow数据类型</span><br><span class="line">def input_fn(set_split=&apos;train&apos;):</span><br><span class="line">    def _fn():</span><br><span class="line">        if set_split == &quot;test&quot;:</span><br><span class="line">            features = &#123;feature_name: tf.constant(test_X)&#125;</span><br><span class="line">            label = tf.constant(test_y)</span><br><span class="line">        else:</span><br><span class="line">            features = &#123;feature_name: tf.constant(train_X)&#125;</span><br><span class="line">            label = tf.constant(train_y)</span><br><span class="line">        return features, label</span><br><span class="line">    return _fn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 训练（拟合）模型</span><br><span class="line">classifier.train(input_fn=input_fn(),</span><br><span class="line">                 steps=1000)</span><br><span class="line">print(&apos;fit done&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 评估准确率</span><br><span class="line">accuracy_score = classifier.evaluate(input_fn=input_fn(&apos;test&apos;), </span><br><span class="line">                                     steps=100)[&quot;accuracy&quot;]</span><br><span class="line">print(&apos;\nAccuracy: &#123;0:f&#125;&apos;.format(accuracy_score))</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/12/03/嘿！有人在偷你的比特币！/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/12/03/嘿！有人在偷你的比特币！/" itemprop="url">Hey! JavaScript Developer, someone is stealing your bitcoin!</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-03T11:29:49+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>To summarizes this event:</p>
<ol>
<li>copay-dash is a popular bitcoin platform which includes event-stream as a dependency.<br>copay-dash 是一个很流行的比特币平台，它使用了event-stream作为依赖包。</li>
<li>For about a week in September, event-stream included flatmap-stream as a dependency, as it was passed along to a new maintainer who added the dependency and removed it a week later.<br>九月份的时候，event-stream 使用了flatmap-stream作为依赖报，它传给了一个新的维护者，这个维护者加上了这个依赖包，一周之后又删掉了。</li>
<li>flatmap-stream had some code hiding at the end of its minified built output which attempts to decode and execute strings from its packaged test/data.js file, using the description of the top-level package as the AES256 key.<br>flatmap-steam 隐藏了一些代码在压缩代码的最后，它尝试使用顶级包的描述中的AES256 key去decode并且运行在test/data.js的字符串.</li>
<li>For any other package, this produces a silently handled error (as the package description/decryption key is wrong). But for copay-dash, this produces some valid JavaScript which runs another round of decryption and executes a malicious script that steals your bitcoin wallet.<br>对于其他包，这些产生了轻微的错误(被try catch了)，但是对于copay-dash， 它产生了有效的JavaScript代码，运行另一轮解密并执行了偷取比特币的恶意脚本。</li>
</ol>
<p>What now?</p>
<ol>
<li><p>Use a lockfile. Whether it’s yarn’s yarn.lock or npm’s package-lock.json, a lockfile ensures that you get the same package versions on every install, so if you’re secure today then you’ll be secure tomorrow as well. Apps that utilize floating dependencies without a lockfile are particularly vulnerable to malicious updates, because they will automatically install the latest patch version of their dependencies — meaning that you may be compromised as soon as your next deploy, if one of your dependencies is compromised and publishes a malicious patch. With a lockfile, you at least limit your exposure to manual developer actions that add or update a package, which can be double-checked via code reviews and organizational policies.<br>使用lockfile, 比如说yarn.lock 或者package-lock.json。 lockfile文件确保了你每次install都会拿到相同版本的依赖包，所以如果你这次安装是安全的，那你下次也是安全的。如果你没有使用lockfile, 下载依赖包的时候会默认下载最新的版本，意味着你可能下载了一个含有恶意代码的版本。如果你某个依赖包遭到了破坏并发布了恶意版本，有lockfile的话，你至少可以限制对于手动添加、更新依赖包的风险，因为可以在代码审查、组织的时候double-check。</p>
</li>
<li><p>Think before you install. This isn’t a panacea — as demonstrated above, it’s easy for attackers to slip malicious code into minified output, which is hard to find even if you knew it was there. But you will drastically reduce your exposure if you stick to popular, well-maintained packages. Before you install a new dependency, first, ask yourself if you really need it. If you already know how to write the code, and it won’t take you more than a few dozen lines, just do it yourself. If you do need the dependency, scope it out before you install. Does it have high download numbers on npm? Does the GitHub repo appear well-maintained and active? Has the package been updated recently? If not, also consider forking the repository and either publishing a fork to npm or installing the package directly from your GitHub; this reduces risk because you aren’t exposed to future malicious updates, and you can read and minify the source yourself so you’re confident about what it really does.<br>下载前三思。这不是万能药 – 正如前面所示范的，将恶意代码写进压缩输出很简单，但是找出来很难，即使你知道它在。但是你会大大减少你的曝光率，如果你坚持使用流行的、维护好的依赖包。在你下载一个新的依赖包前，首先，问下你自己你真的需要吗？如果你已经知道怎么去写这段代码，而且不会很多，不如自己写。如果你真的需要这个依赖包，在你下载前确定范围，它有很高下载量吗？它的Github看起来最近有没有好好在维护？最近有更新吗？如果没有，也考虑下fork这个仓库而且将fork发不到npm或者直接从github下载包。这将减少风险，因为你没有暴露在未来可能的恶意更新中，而且你可以阅读、压缩源代码，知道它究竟在干什么。</p>
</li>
</ol>
<p><a href="https://schneid.io/blog/event-stream-vulnerability-explained/" target="_blank" rel="noopener">原文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/11/30/Centos系统docker的坑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/30/Centos系统docker的坑/" itemprop="url">Centos系统docker的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-30T15:12:20+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/系统/" itemprop="url" rel="index">
                    <span itemprop="name">系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>环境：CentOS Linux release 7.1.1503 (Core)<br>dockerfiles 中有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN mv /app/docker/localtime /etc/localtime</span><br><span class="line">......</span><br><span class="line">RUM rm /app/docker</span><br></pre></td></tr></table></figure></p>
<p>docker build 过程中发现报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv: can&apos;t rename &apos;/app/docker/localtime&apos;: Invalid argument</span><br><span class="line">The command &apos;/bin/sh -c mv /app/docker/localtime /etc/localtime&apos; returned a non-zero code: 1</span><br></pre></td></tr></table></figure></p>
<p>而同样的脚本在另外一个Ubuntu系统下没有这样的报错<br>从 docker info中可以看到<br><img src="https://upload-images.jianshu.io/upload_images/14827444-4a17653f35165366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不正常系统"><br>Centos7<br><img src="https://upload-images.jianshu.io/upload_images/14827444-a3433e310cc982f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常系统"><br>Ubuntu16.04<br>并且可以看到报错信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: overlay: the backing xfs filesystem is formatted without d_type support, which leads to incorrect behavior.</span><br><span class="line">         Reformat the filesystem with ftype=1 to enable d_type support.</span><br><span class="line">         Running without d_type support will not be supported in future releases.</span><br></pre></td></tr></table></figure></p>
<p>Centos7 发行版默认的Kernel版本是3.10，但是Overlay2存储驱动需要4.0以上的kernel版本支持，所以默认使用overlay 并且不支持d_type， 才导致这个报错。<br><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/7.2_release_notes/technology-preview-file_systems" target="_blank" rel="noopener">具体</a><br>解决方法一：<br>格式化 XFS 系统，添加ftype=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前系统xfs</span><br><span class="line">xfs_info /</span><br><span class="line">如果 ftype =0 表示不支持d_type</span><br><span class="line">省略具体格式化方法</span><br></pre></td></tr></table></figure>
<p>解决方法二：<br>修改 storage driver 为 devicemapper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">增加</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;storage-driver&quot;: &quot;devicemapper&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.51cto.com/foxhound/1841487" target="_blank" rel="noopener">docker疑难杂症</a><br><a href="https://www.jianshu.com/p/00ffd8df6010" target="_blank" rel="noopener">docker文件系统参考</a><br><a href="https://github.com/moby/moby/issues/15314" target="_blank" rel="noopener">github上的讨论</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/11/30/ubuntu下安装配置mysql/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/30/ubuntu下安装配置mysql/" itemprop="url">ubuntu下安装配置mysql、Redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-30T11:31:48+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下为Ubuntu 16.04环境<br>安装配置Mysql：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 安装mysql</span><br><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt install mysql-client</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br><span class="line"># 测试安装mysql是否成功</span><br><span class="line">sudo netstat -tap | grep mysql</span><br><span class="line"></span><br><span class="line"># 修改root用户密码</span><br><span class="line">&gt;&gt;&gt; mysql -u root -p</span><br><span class="line"># 进入到mysql</span><br><span class="line">use mysql;</span><br><span class="line">update user set authentication_string=PASSWORD(&apos;123&apos;) where User=&apos;root&apos;;</span><br><span class="line"># 新增用户远程连接权限(指定具体ip地址)</span><br><span class="line">grant all privileges on *.* to &apos;root&apos;@&apos;192.168.33.1&apos; identified by &apos;123&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 修改配置文件</span><br><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf;</span><br><span class="line">修改 bind-address=0.0.0.1</span><br><span class="line"></span><br><span class="line"># 重启mysql服务</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure></p>
<p>安装配置Redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis-server</span><br><span class="line"># 启动</span><br><span class="line">sudo /etc/init.d/redis-server start</span><br><span class="line"># 进入Redis</span><br><span class="line">redis-cli</span><br><span class="line"># 配置开机自启动</span><br><span class="line">chmod +x /etc/init.d/redis-server </span><br><span class="line">update-rc.d redis-server defaults</span><br><span class="line"># 操作</span><br><span class="line">service redis-server start/stop/restart</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/11/28/numpy的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/28/numpy的使用/" itemprop="url">numpy的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-28T16:27:06+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>向量、矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 创建矩阵</span><br><span class="line">matrix = np.array([[1, 4],</span><br><span class="line">                   [2, 5]])</span><br><span class="line"># 矩阵变形</span><br><span class="line">matrix.reshape(1,4)   </span><br><span class="line"># 矩阵的逆</span><br><span class="line">np.linalg.inv(matrix)</span><br><span class="line"># 返回对角线元素</span><br><span class="line">matrix.diagonal()</span><br><span class="line"># 创建矩阵的迹</span><br><span class="line">matrix.diagonal().sum()</span><br><span class="line"># 展开矩阵</span><br><span class="line">matrix.flatten()</span><br><span class="line"># 返回矩阵的秩</span><br><span class="line">np.linalg.matrix_rank(matrix)</span><br><span class="line"># 返回最大元素</span><br><span class="line">np.max(matrix)</span><br><span class="line"># 返回最小元素</span><br><span class="line">np.min(matrix)</span><br><span class="line"># 寻找每列的最大元素</span><br><span class="line">np.max(matrix, axis=0)</span><br><span class="line"># 查看行和列数</span><br><span class="line">matrix.shape</span><br><span class="line"># 查看元素数（行乘列）</span><br><span class="line">matrix.size</span><br><span class="line"># 查看维数</span><br><span class="line">matrix.ndim</span><br><span class="line"># 返回均值</span><br><span class="line">np.mean(matrix)</span><br><span class="line"># 返回方差</span><br><span class="line">np.var(matrix)</span><br><span class="line"># 返回标准差</span><br><span class="line">np.std(matrix)</span><br><span class="line"></span><br><span class="line">#将字典转换为矩阵</span><br><span class="line">from sklearn.feature_extraction import DictVectorizer</span><br><span class="line">data_dict = [&#123;&apos;Red&apos;: 2, &apos;Blue&apos;: 4&#125;,</span><br><span class="line">             &#123;&apos;Red&apos;: 4, &apos;Blue&apos;: 3&#125;,</span><br><span class="line">             &#123;&apos;Red&apos;: 1, &apos;Yellow&apos;: 2&#125;,</span><br><span class="line">             &#123;&apos;Red&apos;: 2, &apos;Yellow&apos;: 2&#125;]</span><br><span class="line"></span><br><span class="line"># 创建 DictVectorizer 对象</span><br><span class="line">dictvectorizer = DictVectorizer(sparse=False)</span><br><span class="line"># 将字典转换为特征矩阵</span><br><span class="line">features = dictvectorizer.fit_transform(data_dict)</span><br><span class="line"># 查看特征矩阵的列名</span><br><span class="line">dictvectorizer.get_feature_names()</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/11/22/Redis原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/22/Redis原理/" itemprop="url">Redis原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-22T10:16:51+08:00">
                2018-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>简单动态字符串（SDS），比起 C 字符串， SDS 具有以下优点：</p>
<ol>
<li>常数复杂度O1获取字符串长度。</li>
<li>杜绝缓冲区溢出。</li>
<li>减少修改字符串长度时所需的内存重分配次数：空间预分配未使用空间，SDS修改后，长度少于1m酒会分配跟len相同大小的未使用空间，大于1m分配1m的未使用空间。</li>
<li>二进制安全。</li>
<li>兼容部分 C 字符串函数。</li>
</ol>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ol>
<li>每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ol>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ol>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
<li>负载因子 ＝哈希表已保存节点数量 / 哈希表大小</li>
<li>索引值计算</li>
</ol>
<ul>
<li>使用字典设置的哈希函数，计算键 key 的哈希值<br>hash = dict-&gt;type-&gt;hashFunction(key);</li>
<li>使用哈希表的 sizemask 属性和哈希值，计算出索引值</li>
<li>根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]<br>index = hash &amp; dict-&gt;ht[x].sizemask;</li>
</ul>
<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><ol>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ol>
<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><ol>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ol>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><ol>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ol>
<h4 id="quicklist-v3-2新增）"><a href="#quicklist-v3-2新增）" class="headerlink" title="quicklist(v3.2新增）"></a>quicklist(v3.2新增）</h4><ol>
<li>由ziplist组成的双向链表，链表中的每一个节点都以压缩列表ziplist的结构保存着数据，而ziplist有多个entry节点，保存着数据。</li>
<li>quicklist宏观上是一个双向链表，因此，它具有一个双向链表的有点，进行插入或删除操作时非常方便，虽然复杂度为O(n)，但是不需要内存的复制，提高了效率，而且访问两端元素复杂度为O(1)。</li>
<li>quicklist微观上是一片片entry节点，每一片entry节点内存连续且顺序存储，可以通过二分查找以 log2(n)log2(n)的复杂度进行定位</li>
</ol>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><ol>
<li>字符串对象的编码可以是int、raw、embstr</li>
<li>列表对象的编码可以是ziplist、linkedlist（quick list？）</li>
<li>哈希对象的编码可以是ziplist、hashtable</li>
<li>集合对象的编码可以是intset（整数集合）、hashtable</li>
<li>有序集合的编码可以是ziplist、skiplist</li>
</ol>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ol>
<li>c语言不具备自动内存回收，redis构建了引用技术实现</li>
<li>只对包含整数值字符串对象进行内存共享：1. 将数据库键值的值指针指向一个现有的值对象。2. 将被共享的值对象引用计数增加一</li>
<li>redis在服务器初始化时，创建0到9999一万个字符串对象</li>
<li>空转时长：对象记录了最后一次被访问时间</li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol>
<li>初始化服务时候，根据dbnum（可配默认16）创建数据库</li>
<li>键空间（字典）：保存了所有键值对</li>
<li>命中次数（keyspace_hits) 不命中次数(keyspace_misses) ，INFO stats命令查看</li>
<li>过期字典：保存了所有键的过期时间（毫秒级时间戳）</li>
<li>persist 实际是把键从过期字典中删除</li>
<li>过期删除策略：惰性删除（所有命令操作键时进行检查）＋定期删除（定期从一定数量数据库取一定数量随机键检查并删除过期键）</li>
<li>RDB持久化（在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中），生成RDB文件时已过期键不会保存，载入RDB文件时，主服务器模式运行时，过期键将被忽略，从服务器模式运行时会载入所有键，但在主从同步时过期键将被删除。</li>
<li>AOF持久化（采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作），当过期键被删除的时候，向AOF文件追加一条DEL命令。AOF重写时，过期键被检查而不会保存到AOF文件。</li>
<li>数据库通知功能（notifyKeyspaceEvent)</li>
</ol>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><ol>
<li>生成RDB文件命令：SAVE，阻赛Redis服务器进程，直到RDB文件创建完毕为止。BGSAVE，派生出一个子进程，由子进程负责生成RDB文件，服务器主进程基础处理命令请求。</li>
<li>serverCron默认每隔100ms执行检查save选项保存条件（dirty,lastsave)是否满足，如满足执行BGSAVE</li>
</ol>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><ol>
<li>appendfsync选项。安全性always&gt;every sec&gt;no。 效率no&gt;everysec&gt;always</li>
</ol>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><ol>
<li>redis是事件驱动程序，服务器处理事件分为时间事件、文件事件</li>
<li>文件事件是对套接字操作的抽奖</li>
<li>服务器在一半情况下只执行serverCron函数一个时间事件</li>
<li>因为事件循环，时间事件的实际处理事件会比设定时间晚一些</li>
</ol>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><ol>
<li>服务器状态结构使用 clients 链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li>
<li>客户端状态的 flags 属性使用不同标志来表示客户端的角色， 以及客户端当前所处的状态。</li>
<li>输入缓冲区记录了客户端发送的命令请求， 这个缓冲区的大小不能超过 1 GB 。</li>
<li>命令的参数和参数个数会被记录在客户端状态的 argv 和 argc 属性里面， 而 cmd 属性则记录了客户端要执行命令的实现函数。</li>
<li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用， 其中固定大小缓冲区的最大大小为 16 KB ， 而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li>
<li>输出缓冲区限制值有两种， 如果输出缓冲区的大小超过了服务器设置的硬性限制， 那么客户端会被立即关闭； 除此之外， 如果客户端在一定时间内， 一直超过服务器设置的软性限制， 那么客户端也会被关闭。</li>
<li>当一个客户端通过网络连接连上服务器时， 服务器会为这个客户端创建相应的客户端状态。 网络连接关闭、 发送了不合协议格式的命令请求、 成为 CLIENT_KILL 命令的目标、 空转时间超时、 输出缓冲区的大小超出限制， 以上这些原因都会造成客户端被关闭。</li>
<li>处理 Lua 脚本的伪客户端在服务器初始化时创建， 这个客户端会一直存在， 直到服务器关闭。</li>
<li>载入 AOF 文件时使用的伪客户端在载入工作开始时动态创建， 载入工作完毕之后关闭。</li>
</ol>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><ol>
<li>一个命令请求从发送到完成主要包括以下步骤： <ul>
<li>客户端将命令请求发送给服务器； </li>
<li>服务器读取命令请求，并分析出命令参数； </li>
<li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复； </li>
<li>服务器将命令回复返回给客户端。</li>
</ul>
</li>
<li>serverCron 函数默认每隔 100 毫秒执行一次， 它的工作主要包括更新服务器状态信息， 处理服务器接收的 SIGTERM 信号， 管理客户端资源和数据库状态， 检查并执行持久化操作， 等等。</li>
<li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤： <ul>
<li>初始化服务器状态； </li>
<li>载入服务器配置； </li>
<li>初始化服务器数据结构； </li>
<li>还原数据库状态； </li>
<li>执行事件循环。</li>
</ul>
</li>
</ol>
<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><ol>
<li>部分重同步通过复制偏移量、复制积压缓冲区、服务器运行 ID 三个部分来实现。</li>
<li>在复制操作刚开始的时候， 从服务器会成为主服务器的客户端， 并通过向主服务器发送命令请求来执行复制步骤， 而在复制操作的后期， 主从服务器会互相成为对方的客户端。</li>
<li>主服务器通过向从服务器传播命令来更新从服务器的状态， 保持主从服务器一致， 而从服务器则通过向主服务器发送命令(REPLACONFACK)来进行心跳检测， 以及命令丢失检测。</li>
</ol>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><ol>
<li>一个运行在特殊模式下的 Redis 服务器， 它使用了和普通模式不同的命令表， 所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。</li>
<li>Sentinel 会读入用户指定的配置文件， 为每个要被监视的主服务器创建相应的实例结构， 并创建连向主服务器的命令连接和订阅连接， 其中命令连接用于向主服务器发送命令请求， 而订阅连接则用于接收指定频道的消息。</li>
<li>Sentinel 通过向主服务器发送 INFO 命令来获得主服务器属下所有从服务器的地址信息， 并为这些从服务器创建相应的实例结构， 以及连向这些从服务器的命令连接和订阅连接。</li>
<li>在一般情况下， Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 INFO 命令， 当主服务器处于下线状态， 或者 Sentinel 正在对主服务器进行故障转移操作时， Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。</li>
<li>对于监视同一个主服务器和从服务器的多个 Sentinel 来说， 它们会以每两秒一次的频率， 通过向被监视服务器的 <strong>sentinel</strong>:hello 频道发送消息来向其他 Sentinel 宣告自己的存在。</li>
<li>每个 Sentinel 也会从 <strong>sentinel</strong>:hello 频道中接收其他 Sentinel 发来的信息， 并根据这些信息为其他 Sentinel 创建相应的实例结构， 以及命令连接。</li>
<li>Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接， Sentinel 与 Sentinel 之间则只创建命令连接。</li>
<li>Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令， 并根据实例对 PING 命令的回复来判断实例是否在线： 当一个实例在指定的时长中连续向 Sentinel 发送无效回复时， Sentinel 会将这个实例判断为主观下线。</li>
<li>当 Sentinel 将一个主服务器判断为主观下线时， 它会向同样监视这个主服务器的其他 Sentinel 进行询问， 看它们是否同意这个主服务器已经进入主观下线状态。</li>
<li>当 Sentinel 收集到足够多的主观下线投票之后， 它会将主服务器判断为客观下线， 并发起一次针对主服务器的故障转移操作。</li>
<li>相似RAFT算法选取领头Sentinel</li>
</ol>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><ol>
<li>节点通过握手来将其他节点添加到自己所处的集群当中。</li>
<li>集群中的 16384 个槽可以分别指派给集群中的各个节点， 每个节点都会记录哪些槽指派给了自己， 而哪些槽又被指派给了其他节点。</li>
<li>节点在接到一个命令请求时， 会先检查这个命令请求要处理的键所在的槽是否由自己负责， 如果不是的话， 节点将向客户端返回一个 MOVED 错误， MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li>
<li>对 Redis 集群的重新分片工作是由客户端执行的， 重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</li>
<li>如果节点 A 正在迁移槽 i 至节点 B ， 那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时， 节点 A 会向客户端返回一个 ASK 错误， 指引客户端到节点 B 继续查找指定的数据库键。</li>
<li>MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点， 而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</li>
<li>集群里的从节点用于复制主节点， 并在主节点下线时， 代替主节点继续处理命令请求。</li>
<li>集群中的节点通过发送和接收消息来进行通讯， 常见的消息包括 MEET 、 PING 、 PONG 、 PUBLISH 、 FAIL 五种。</li>
</ol>
<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><ol>
<li>服务器状态在 pubsub_channels 字典保存了所有频道的订阅关系： SUBSCRIBE 命令负责将客户端和被订阅的频道关联到这个字典里面， 而 UNSUBSCRIBE 命令则负责解除客户端和被退订频道之间的关联。</li>
<li>服务器状态在 pubsub_patterns 链表保存了所有模式的订阅关系： PSUBSCRIBE 命令负责将客户端和被订阅的模式记录到这个链表中， 而 UNSUBSCRIBE 命令则负责移除客户端和被退订模式在链表中的记录。</li>
<li>PUBLISH 命令通过访问 pubsub_channels 字典来向频道的所有订阅者发送消息， 通过访问 pubsub_patterns 链表来向所有匹配频道的模式的订阅者发送消息。</li>
<li>PUBSUB 命令的三个子命令都是通过读取 pubsub_channels 字典和 pubsub_patterns 链表中的信息来实现的。</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ol>
<li>事务提供了一种将多个命令打包， 然后一次性、有序地执行的机制。</li>
<li>多个命令会被入队到事务队列中， 然后按先进先出（FIFO）的顺序执行。</li>
<li>事务在执行过程中不会被中断， 当事务队列中的所有命令都被执行完毕之后， 事务才会结束。</li>
<li>带有 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联， 当键被修改时， 程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 标志打开。</li>
<li>只有在客户端的 REDIS_DIRTY_CAS 标志未被打开时， 服务器才会执行客户端提交的事务， 否则的话， 服务器将拒绝执行客户端提交的事务。</li>
<li>Redis 的事务总是保证 ACID 中的原子性、一致性和隔离性， 当服务器运行在 AOF 持久化模式下， 并且 appendfsync 选项的值为 always 时， 事务也具有耐久性。</li>
<li>Redis事务不支持事务回滚机制，即使实行期间出现了错误也会全部执行所有命令。</li>
</ol>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ol>
<li>SORT 命令通过将被排序键包含的元素载入到数组里面， 然后对数组进行排序来完成对键进行排序的工作。</li>
<li>在默认情况下， SORT 命令假设被排序键包含的都是数字值， 并且以数字值的方式来进行排序。</li>
<li>如果 SORT 命令使用了 ALPHA 选项， 那么 SORT 命令假设被排序键包含的都是字符串值， 并且以字符串的方式来进行排序。</li>
<li>SORT 命令的排序操作由快速排序算法实现。</li>
<li>SORT 命令会根据用户是否使用了 DESC 选项来决定是使用升序对比还是降序对比来比较被排序的元素</li>
<li>当 SORT 命令使用了 BY 选项时， 命令使用其他键的值作为权重来进行排序操作。</li>
<li>当 SORT 命令使用了 LIMIT 选项时， 命令只保留排序结果集中 LIMIT 选项指定的元素。</li>
<li>当 SORT 命令使用了 GET 选项时， 命令会根据排序结果集中的元素， 以及 GET 选项给定的模式， 查找并返回其他键的值， 而不是返回被排序的元素。</li>
<li>当 SORT 命令使用了 STORE 选项时， 命令会将排序结果集保存在指定的键里面。</li>
<li>当 SORT 命令同时使用多个选项时， 命令先执行排序操作（可用的选项为 ALPHA 、 ASC 或 DESC 、 BY ）， 然后执行 LIMIT 选项， 之后执行 GET 选项， 再之后执行 STORE 选项， 最后才将排序结果集返回给客户端。</li>
<li>除了 GET 选项之外， 调整选项的摆放位置不会影响 SORT 命令的排序结果。</li>
</ol>
<h1 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h1><ol>
<li>Redis 使用 SDS 来保存位数组。</li>
<li>SDS 使用逆序来保存位数组， 这种保存顺序简化了 SETBIT 命令的实现， 使得 SETBIT 命令可以在不移动现有二进制位的情况下， 对位数组进行空间扩展。</li>
<li>BITCOUNT 命令使用了查表算法和 variable-precision SWAR 算法来优化命令的执行效率。</li>
<li>BITOP 命令的所有操作都使用 C 语言内置的位操作来实现。</li>
</ol>
<h1 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h1><ol>
<li>Redis 的慢查询日志功能用于记录执行时间超过指定时长的命令。</li>
<li>Redis 服务器将所有的慢查询日志保存在服务器状态的 slowlog 链表中， 每个链表节点都包含一个 slowlogEntry 结构， 每个 slowlogEntry 结构代表一条慢查询日志。</li>
<li>打印和删除慢查询日志可以通过遍历 slowlog 链表来完成。</li>
<li>slowlog 链表的长度就是服务器所保存慢查询日志的数量。</li>
<li>新的慢查询日志会被添加到 slowlog 链表的表头， 如果日志的数量超过 slowlog-max-len 选项的值， 那么多出来的日志会被删除。</li>
</ol>
<h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><ol>
<li>客户端可以通过执行 MONITOR 命令， 将客户端转换成监视器， 接收并打印服务器处理的每个命令请求的相关信息。</li>
<li>当一个客户端从普通客户端变为监视器时， 该客户端的 REDIS_MONITOR 标识会被打开。</li>
<li>服务器将所有监视器都记录在 monitors 链表中。</li>
<li>每次处理命令请求时， 服务器都会遍历 monitors 链表， 将相关信息发送给监视器。</li>
</ol>
<h1 id="LUA"><a href="#LUA" class="headerlink" title="LUA"></a>LUA</h1><p>好处</p>
<ol>
<li>［原子操作］lua脚本式在redis中原子执行的，在执行过程中不会插入其他命令</li>
<li>［可复用］lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这些命令常驻在Redis内存中，实现复用的效果。</li>
<li>［高性能］lua脚本可以将多条命令一次性打包，有效的减少网络开销。</li>
</ol>
<p>要点：</p>
<ol>
<li>Redis 服务器在启动时， 会对内嵌的 Lua 环境执行一系列修改操作， 从而确保内嵌的 Lua 环境可以满足 Redis 在功能性、安全性等方面的需要。</li>
<li>Redis 服务器专门使用一个伪客户端来执行 Lua 脚本中包含的 Redis 命令。</li>
<li>Redis 使用脚本字典来保存所有被 EVAL 命令执行过， 或者被 SCRIPT_LOAD 命令载入过的 Lua 脚本， 这些脚本可以用于实现 SCRIPT_EXISTS 命令， 以及实现脚本复制功能。</li>
<li>EVAL 命令为客户端输入的脚本在 Lua 环境中定义一个函数， 并通过调用这个函数来执行脚本。</li>
<li>EVALSHA 命令通过直接调用 Lua 环境中已定义的函数来执行脚本。</li>
<li>SCRIPT_FLUSH 命令会清空服务器 lua_scripts 字典中保存的脚本， 并重置 Lua 环境。</li>
<li>SCRIPT_EXISTS 命令接受一个或多个 SHA1 校验和为参数， 并通过检查 lua_scripts 字典来确认校验和对应的脚本是否存在。</li>
<li>SCRIPT_LOAD 命令接受一个 Lua 脚本为参数， 为该脚本在 Lua 环境中创建函数， 并将脚本保存到 lua_scripts 字典中。</li>
<li>服务器在执行脚本之前， 会为 Lua 环境设置一个超时处理钩子， 当脚本出现超时运行情况时， 客户端可以通过向服务器发送 SCRIPT_KILL 命令来让钩子停止正在执行的脚本， 或者发送 SHUTDOWN nosave 命令来让钩子关闭整个服务器。</li>
<li>主服务器复制 EVAL 、 SCRIPT_FLUSH 、 SCRIPT_LOAD 三个命令的方法和复制普通 Redis 命令一样 —— 只要将相同的命令传播给从服务器就可以了。</li>
<li>主服务器在复制 EVALSHA 命令时， 必须确保所有从服务器都已经载入了 EVALSHA 命令指定的 SHA1 校验和所对应的 Lua 脚本， 如果不能确保这一点的话， 主服务器会将 EVALSHA 命令转换成等效的 EVAL 命令， 并通过传播 EVAL 命令来获得相同的脚本执行效果。</li>
</ol>
<h1 id="Redis与MC对比"><a href="#Redis与MC对比" class="headerlink" title="Redis与MC对比"></a>Redis与MC对比</h1><p><img src="https://upload-images.jianshu.io/upload_images/14827444-a136b240901c9e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对比"><br><a href="https://segmentfault.com/a/1190000015706221?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly" target="_blank" rel="noopener">why redis</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/11/21/设计可拓展框架/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/21/设计可拓展框架/" itemprop="url">设计可拓展框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-21T17:33:57+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/架构设计/" itemprop="url" rel="index">
                    <span itemprop="name">架构设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>可拓展框架基本模式</p>
<ol>
<li>面向流程拆分：分层结构（通过分层强制约束两两依赖，缺点在于冗余的调用、性能）<br> 比如MVC分层</li>
<li>面向服务拆分：SOA（服务＋ESB） 、微服务</li>
<li>面向功能拆分：微内核架构</li>
</ol>
<p>微服务的基础设施：</p>
<ol>
<li>自动化测试</li>
<li>自动化部署</li>
<li>配置中心</li>
<li>接口框架</li>
<li>api网关</li>
<li>服务发现</li>
<li>服务路由</li>
<li>服务容错</li>
<li>服务监控</li>
<li>服务跟踪</li>
<li>服务安全</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://angelteng.github.io/blog/blog/2018/11/21/PHP项目中并发处理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Angel Teng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code war of Angel">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/21/PHP项目中并发处理/" itemprop="url">PHP项目中并发处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-21T16:55:41+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结一下PHP项目中并发处理：</p>
<h4 id="高并发业务处理的重点在于原子操作，常见操作："><a href="#高并发业务处理的重点在于原子操作，常见操作：" class="headerlink" title="高并发业务处理的重点在于原子操作，常见操作："></a>高并发业务处理的重点在于原子操作，常见操作：</h4><ol>
<li>redis-&gt;incr </li>
<li>如果redis是单机，可以使用watch方案<pre><code>WATCH mykey
 val = GET mykey
 val = val + 1
 MULTI
 SET mykey $val
 EXEC
</code></pre></li>
<li><p>如果redis是集群，使用<a href="http://doc.redisfans.com/string/setnx.html" target="_blank" rel="noopener">redis-&gt;setNX</a><br> 死锁问题： </p>
<ol start="0">
<li>上锁的 key 保存的是 unix 时间戳，假如 key 值的时间戳小于当前的时间戳，表示锁已经不再有效。</li>
<li>C4 向 lock.foo 发送 SETNX 命令。因为崩溃掉的 C3 还锁着 lock.foo ，所以 Redis 向 C4 返回 0 。</li>
<li>C4 向 lock.foo 发送 GET 命令，查看 lock.foo 的锁是否过期。如果不，则休眠(sleep)一段时间，并在之后重试。另一方面，如果 lock.foo 内的 unix 时间戳比当前时间戳老，C4 执行以下命令：<br>GETSET lock.foo <current 1="" unix="" timestamp="" +="" lock="" timeout=""><br>因为 GETSET 的作用，C4 可以检查看 GETSET 的返回值，确定 lock.foo 之前储存的旧值仍是那个过期时间戳，如果是的话，那么 C4 获得锁。</current></li>
<li>如果其他客户端，比如 C5，比 C4 更快地执行了 GETSET 操作并获得锁，那么 C4 的 GETSET 操作返回的就是一个未过期的时间戳(C5 设置的时间戳)。C4 只好从第一步开始重试。</li>
<li>即便 C4 的 GETSET 操作对 key 进行了修改，这对未来也没什么影响。</li>
</ol>
</li>
</ol>
<ol start="4">
<li>队列方案：每次pop一个出来，但是数量多的时候会造成hotkey ，时间复杂度与数量相关</li>
</ol>
<h4 id="项目中整理处理："><a href="#项目中整理处理：" class="headerlink" title="项目中整理处理："></a>项目中整理处理：</h4><ol>
<li><p>降级：根据业务判断降级内容及手段。<br> 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br> 梳理业务，可以参考日志级别设置预案：<br> 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br> 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br> 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br> 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
<p> 降级按照是否自动化可分为：自动开关降级和人工开关降级。<br> 降级按照功能可分为：读服务降级、写服务降级。<br> 降级按照处于的系统层次可分为：多级降级。</p>
<p> 降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：<br> 页面降级：在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；<br> 页面片段降级：比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；<br> 页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；<br> 服务功能降级：比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；<br> 读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；<br> 写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。<br> 爬虫降级：在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。<br> <a href="http://jinnianshilongnian.iteye.com/blog/2306477" target="_blank" rel="noopener">参考《亿级流量网站架构核心设计》</a></p>
</li>
<li><p>熔断：关键在统一的api调用层，阈值设计。比如利用apcu，计算某个底层接口超时/返回错误的情况，假如在一个30s的周期内，失败次数超过n次，则不调用这个接口，直接返回某个约定值。</p>
</li>
<li><p>限流：基于请求、基于资源（cpu/..)<br> 限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</p>
<p> 一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p>
<p> 先有缓存这个银弹，后有限流来应对618、双十一高并发流量，在处理高并发问题上可以说是如虎添翼，不用担心瞬间流量导致系统挂掉或雪崩，最终做到有损服务而不是不服务；限流需要评估好，不可乱用，否则会正常流量出现一些奇怪的问题而导致用户抱怨。</p>
<p> 限流算法<br> 常见的限流算法有：令牌桶、漏桶。计数器也可以进行粗暴限流实现。<br> <a href="http://jinnianshilongnian.iteye.com/blog/2305117" target="_blank" rel="noopener">参考《亿级流量网站架构核心设计》</a></p>
</li>
<li><p>排队：排队模块、调度模块、服务模块</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://erp.ainnovation.com/avatar/thumb/tenganqi@chuangxin.com.jpg" alt="Angel Teng">
            
              <p class="site-author-name" itemprop="name">Angel Teng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/category/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Angel Teng</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
